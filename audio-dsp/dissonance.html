<!DOCTYPE html>
<html>
  <!-- license: AGPL-3.0 -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ðŸŒ± dissonance curves</title>
    <style>
      body {
        background-color: #222;
        max-width: 500px;
        margin: auto;
        font-family: serif;
        font-size: 1.2em;
        color: #edd;
        text-align: left;
        padding: 20px 8px;
      }
      @font-face {
        font-family: "FontWithASyntaxHighlighter";
        src: url("/fonts/FontWithASyntaxHighlighter-Regular.woff2")
          format("woff2");
      }
      a {
        color: cyan;
        font-size: 1em;
        cursor: pointer;
      }
      textarea,
      pre {
        overflow: auto;
        font-family: "FontWithASyntaxHighlighter", monospace;
        padding: 8px;
        font-size: 12px;
        border: 0;
        outline: none;
        background-color: #44444490;
        border: 0;
        color: white;
        width: 100%;
        margin-top: 8px;
        box-sizing: border-box;
      }
      ul,
      ol {
        padding-left: 20px;
      }
      canvas {
        max-width: 100%;
        background-color: #44444490;
      }
    </style>
    <script>
      // render codeblock from script tag
      let codeblock = (scriptElement, indent = 0) => {
        const script = document.currentScript;
        const pre = document.createElement("pre");
        pre.textContent = getCode(scriptElement, indent);
        script.after(pre);
      };
      function getCode(scriptElement, indent = 0) {
        return scriptElement.innerText
          .split("\n")
          .map((line) => line.slice(indent))
          .filter((x) => x && !x.startsWith("codeblock("))
          .join("\n");
      }
    </script>
  </head>
  <body>
    <h2>ðŸŒ± dissonance curves</h2>
    <p>...</p>

    <script>
      const ctx = new AudioContext();
      // init audio context
      document.addEventListener("click", function firstClick() {
        ctx.resume(); // autoply policy
        document.removeEventListener("click", firstClick);
      });

      const lerp = (v, min, max) => v * (max - min) + min;
      const invLerp = (v, min, max) => (v - min) / (max - min);
      const remap = (v, vmin, vmax, omin, omax) =>
        lerp(invLerp(v, vmin, vmax), omin, omax);

      class DSPRepl extends HTMLElement {
        static observedAttributes = ["code", "rows"];
        worklet;
        init() {
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "").replace("<!--", "").replace("-->", "").trim();

          const rows = this.getAttribute("rows") ?? 4;
          if (!code) {
            return;
          }
          this.innerHTML = "";
          this.insertAdjacentHTML(
            "beforeend",
            `<div style="border:2px solid #222;padding:0;">
                <textarea id="code" spellcheck="false" rows="${rows}"></textarea>
                <canvas height="60"></canvas>
                <a class="play">play</a> | <a class="stop">stop</a>
                </div>
                  `
          );
          // draw logic
          this.canvas = this.querySelector("canvas");
          this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;
          this.canvas.height =
            this.canvas.clientHeight * window.devicePixelRatio;
          this.drawContext = this.canvas.getContext("2d");
          this.drawSilence(this.drawContext);

          // repl logic
          const input = this.querySelector("textarea");
          input.value = code;
          input.style = "margin:0;border-bottom:2px solid #222";
          this.input = input;

          this.querySelector(".play").onclick = () => this.play();
          this.querySelector(".stop").onclick = () => this.stop();
          input.addEventListener("keydown", async (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              const hash = btoa(input.value);
              let urlCode = window.location.hash.slice(1);
              this.play();
            }
            if ((e.ctrlKey || e.altKey) && e.code === "Period") {
              e.preventDefault();
              this.stop();
            }
          });
        }

        async play() {
          await ctx.resume();
          this.stop();
          this.worklet = await this.runWorklet(ctx, this.input.value);
          this.worklet.port.onmessage = (e) =>
            requestAnimationFrame(() => this.drawBuffer(e.data));
        }
        stop() {
          this.worklet?.disconnect();
          this.worklet?.port.postMessage("stop");
        }

        async runWorklet(ac, code) {
          const name = `worklet-${Date.now()}`;
          const math = Object.getOwnPropertyNames(Math).join(",");
          let prelude = `const {${math}} = Math;\n`;
          const dspScripts = document
            .querySelectorAll("script.dsp-prelude")
            .forEach((script) => {
              prelude += script.textContent;
            });
          const workletCode = `${prelude}
      // start of user code
      ${code}
      // end of user code, I hope you have define an dsp function..
            class MyProcessor extends AudioWorkletProcessor {
              constructor() {
                super();
                this.t = 0;
                this.active = true;
                this.framebuffer = new Float32Array(Math.floor(sampleRate/30));
                this.port.onmessage = (e) => e.data === "stop" && (this.active = false)
              }
              process(inputs, outputs, parameters) {
                const output = outputs[0];
                for (let i = 0; i < output[0].length; i++) {
                  let out = dsp(this.t/sampleRate)
                  for (let c = 0; c < output.length; c++)
                    output[c][i] = out;
                  this.t++;
                  this.framebuffer[this.t%this.framebuffer.length] = out;
                  if(this.t % this.framebuffer.length === 0 && this.t > 0) {
                    this.port.postMessage(this.framebuffer)
                  }
                }
                return this.active;
              }
            }
            registerProcessor('${name}', MyProcessor);`;
          await ac.resume();
          const dataURL = `data:text/javascript;base64,${btoa(workletCode)}`;
          await ac.audioWorklet.addModule(dataURL);
          const node = new AudioWorkletNode(ac, name);
          node.connect(ac.destination);
          return node;
        }

        drawBuffer(samples) {
          const ctx = this.drawContext;
          const canvas = ctx.canvas;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.lineWidth = 2;
          ctx.strokeStyle = "white";
          let x0 = 1;
          let x1 = samples.length;
          let y0 = -1;
          let y1 = 1;
          let px0 = 0;
          let px1 = ctx.canvas.width;
          let py0 = ctx.canvas.height - ctx.lineWidth;
          let py1 = ctx.lineWidth;
          ctx.beginPath();
          for (let px = 0; px < ctx.canvas.width; px++) {
            const x = remap(px, px0, px1, x0, x1);
            const y = samples[Math.floor(x)];
            const py = remap(y, y0, y1, py0, py1);
            px === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
          }
          ctx.stroke();
        }

        drawSilence(ctx, color = "white", lineWidth = 2) {
          const canvas = ctx.canvas;
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height / 2);
          ctx.lineTo(canvas.width, canvas.height / 2);
          ctx.stroke();
        }

        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          this.init();
        }
      }
      customElements.define("dsp-repl", DSPRepl);
    </script>

    <script>
      class CanvasGarden extends HTMLElement {
        static observedAttributes = ["code", "rows", "width", "height"];
        init() {
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "")
              .replace("<!--", "")
              .replace("-->", "")
              .trim() ||
            "";
          this.innerHTML = "";
          const rows = this.getAttribute("rows") ?? 6;
          const width = this.getAttribute("width") ?? 800;
          const height = this.getAttribute("height") ?? 400;

          this.insertAdjacentHTML(
            "beforeend",
            `<div style="border:2px solid #222;padding:0;">
        <textarea id="code" spellcheck="false" rows="${rows}" style="margin:0;border-bottom:2px solid #222;width:100%"></textarea>
        <canvas width="${width}" height="${height}" style="max-width:100%"></canvas>
        </div>`
          );
          // draw logic
          this.canvas = this.querySelector("canvas");
          this.ctx = this.canvas.getContext("2d");
          // repl logic
          const input = this.querySelector("textarea");
          input.value = code;
          this.input = input;
          this.update();

          input.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              this.update();
            } else if ((e.ctrlKey || e.altKey) && e.key === ".") {
              e.preventDefault();
              this.stop();
            }
          });
        }
        draw(draw) {
          this.lastFrame = this.lastFrame || 0;
          const self = this;
          self.frame = window.requestAnimationFrame(function paint(t) {
            if (self.lastFrame) {
              let dt = t - self.lastFrame;
              draw(t / 1000, dt);
            }
            self.lastFrame = t;
            self.frame = requestAnimationFrame(paint);
          });
        }
        stop() {
          if (this.frame) {
            window.cancelAnimationFrame(this.frame);
            return;
          }
        }
        R(r, g, b, a = 1) {
          return `rgba(${r},${g},${b},${a})`;
        }
        setCode(code) {
          this.code = code;
          this.input.value = code;
          this.update();
        }
        async update() {
          const ctx = this.ctx;
          const math = Object.getOwnPropertyNames(Math).join(",");
          const prelude = `const {${math}} = Math;\n`;
          const code = `${prelude}
const ctx = self.ctx, canvas = ctx.canvas;
// dwitter.net style:
const S = Math.sin, C = Math.cos, T = Math.tan, R = self.R, c = canvas, x = ctx;
${this.input.value}
typeof draw !== 'undefined' && self.draw(draw);`;
          const fn = new Function("self", code);
          this.stop();
          fn(this);
        }
        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          if (name === "code") {
            this.setCode(newValue);
          }
        }
      }
      customElements.define("canvas-garden", CanvasGarden);
    </script>

    <script>
      function plot(
        fn,
        ctx,
        xrange = [],
        yrange = [],
        color = "white",
        lineWidth = 1
      ) {
        // these 3 functions are very good to know..
        const lerp = (v, min, max) => v * (max - min) + min;
        const invLerp = (v, min, max) => (v - min) / (max - min);
        const remap = (v, vmin, vmax, omin, omax) =>
          lerp(invLerp(v, vmin, vmax), omin, omax);
        // prepare draw context
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        const [cw, ch] = [ctx.canvas.width, ctx.canvas.height - ctx.lineWidth];
        const [x0 = -1, x1 = 1, px0 = 0, px1 = cw] = xrange;
        const [y0 = -1, y1 = 1, py0 = ch, py1 = ctx.lineWidth] = yrange;
        // actual draw logic
        ctx.beginPath();
        for (let px = px0; px < px1; px++) {
          const x = remap(px, px0, px1, x0, x1);
          const y = fn(x);
          const py = remap(y, y0, y1, py0, py1);
          px === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      window.plot = plot;
    </script>
    <canvas-garden rows="16">
      <!--
let dissonance = (f1, f2, a = 3.5, b = 5.75) => {
  const deltaF = Math.abs(f2 - f1);
  return Math.exp(-a * deltaF) - Math.exp(-b * deltaF);
}

let harmonicity = (spectrum, base, ratio) => {
  let sum = 0;
  for (let i = 0; i < spectrum.length; i++) {
    for (let j = 0; j < spectrum.length; j++) {
      const f1 = spectrum[i]*base;
      const f2 = spectrum[j]*base*ratio;
      const dis = dissonance(f1,f2,.1,.2);
      sum+=dis
    }
  }
  return sum
};

let spectrum = [1,2,3,4,5,6];
console.log(harmonicity(spectrum, 440, 1));

c.width = 800;
plot(
  (x) => {
    return harmonicity(spectrum, 60, x);
  },
  ctx,
  [1, 2], // xrange
  [0, 1.5]
);

  -->
    </canvas-garden>
    <script type="text/javascript" class="dsp-prelude">
      class HarmonicOsc {
        constructor(amplitudes, phase = 0) {
          this.amplitudes = amplitudes;
          this.phases = new Array(amplitudes.length).fill(phase);
          this.nyquist = sampleRate / 2;
        }
        update(freq, maxPartials = this.amplitudes.length, a0 = 0) {
          let max = Math.floor((this.nyquist / freq + 1) / 2);
          let amps = this.amplitudes.length;
          let partials = Math.min(max, amps);
          let sum = a0;
          for (let i = 0; i < partials; i++) {
            let harmonic = i + 1;
            let dt = (harmonic * freq) / sampleRate;
            this.phases[i] = (this.phases[i] + dt) % 1;
            if (i <= maxPartials) {
              const phase = this.phases[i] * 2 * Math.PI;
              sum += Math.sin(phase) * this.amplitudes[i];
            }
          }
          return sum;
        }
      }
      let harmonics = (n, fn) => {
        let amps = new Array(n).fill(0);
        for (let i = 0; i < n; i++) {
          amps[i] = fn(i + 1);
        }
        return amps;
      };
    </script>
    <dsp-repl rows="8"
      ><!-- 
// populate first 64 partial amplitudes for a sawtooth wave
let saw = harmonics(64, n => -2/(n*PI))
let osc1 = new HarmonicOsc(saw)
let dsp = (t) => osc1.update(60.1, (sin(t*1)+1)/2*64 )/2
//                                 ^ modulate maxPartials
--></dsp-repl
    >
    <details>
      <summary id="loc">show page source</summary>
      <pre id="pre"></pre>
    </details>
    <p>
      <a href="/">back to garten.salat</a>
    </p>

    <script>
      const html = document.querySelector("html").outerHTML;
      const loc = html.split("\n").length;
      document.querySelector("#pre").textContent = html;
      document.querySelector("#loc").textContent = `show source (${loc} loc)`;
    </script>
  </body>
</html>
