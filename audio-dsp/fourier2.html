<!DOCTYPE html>
<html>
  <!-- license: AGPL-3.0 -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ðŸŒ± the fourier series II</title>
    <style>
      body {
        background-color: #222;
        max-width: 500px;
        margin: auto;
        font-family: serif;
        font-size: 1.2em;
        color: #edd;
        text-align: left;
        padding: 20px 8px;
      }
      @font-face {
        font-family: "FontWithASyntaxHighlighter";
        src: url("/fonts/FontWithASyntaxHighlighter-Regular.woff2")
          format("woff2");
      }
      a {
        color: cyan;
        font-size: 1em;
        cursor: pointer;
      }
      textarea,
      pre {
        overflow: auto;
        font-family: "FontWithASyntaxHighlighter", monospace;
        padding: 8px;
        font-size: 12px;
        border: 0;
        outline: none;
        background-color: #44444490;
        border: 0;
        color: white;
        width: 100%;
        margin-top: 8px;
        box-sizing: border-box;
      }
      ul,
      ol {
        padding-left: 20px;
      }
      canvas {
        max-width: 100%;
        background-color: #44444490;
      }
    </style>
    <script>
      // render codeblock from script tag
      let codeblock = (scriptElement, indent = 0) => {
        const script = document.currentScript;
        const pre = document.createElement("pre");
        pre.textContent = getCode(scriptElement, indent);
        script.after(pre);
      };
      function getCode(scriptElement, indent = 0) {
        return scriptElement.innerText
          .split("\n")
          .map((line) => line.slice(indent))
          .filter((x) => x && !x.startsWith("codeblock("))
          .join("\n");
      }
    </script>
  </head>
  <body>
    <script>
      class CanvasGarden extends HTMLElement {
        static observedAttributes = ["code", "rows", "width", "height"];
        init() {
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "")
              .replace("<!--", "")
              .replace("-->", "")
              .trim() ||
            "";
          this.innerHTML = "";
          const rows = this.getAttribute("rows") ?? 6;
          const width = this.getAttribute("width") ?? 800;
          const height = this.getAttribute("height") ?? 400;

          this.insertAdjacentHTML(
            "beforeend",
            `<div style="border:2px solid #222;padding:0;">
              <canvas width="${width}" height="${height}" style="max-width:100%"></canvas>
              <textarea id="code" spellcheck="false" rows="${rows}" style="margin:0;border-bottom:2px solid #222;width:100%"></textarea>
            </div>`
          );
          // draw logic
          this.canvas = this.querySelector("canvas");
          this.ctx = this.canvas.getContext("2d");
          // repl logic
          const input = this.querySelector("textarea");
          input.value = code;
          this.input = input;
          this.update();

          input.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              this.update();
            } else if ((e.ctrlKey || e.altKey) && e.key === ".") {
              e.preventDefault();
              this.stop();
            }
          });
        }
        draw(draw) {
          this.lastFrame = this.lastFrame || 0;
          const self = this;
          self.frame = window.requestAnimationFrame(function paint(t) {
            if (self.lastFrame) {
              let dt = t - self.lastFrame;
              draw(t / 1000, dt);
            }
            self.lastFrame = t;
            self.frame = requestAnimationFrame(paint);
          });
        }
        stop() {
          if (this.frame) {
            window.cancelAnimationFrame(this.frame);
            return;
          }
        }
        R(r, g, b, a = 1) {
          return `rgba(${r},${g},${b},${a})`;
        }
        setCode(code) {
          this.code = code;
          this.input.value = code;
          this.update();
        }
        async update() {
          const ctx = this.ctx;
          const math = Object.getOwnPropertyNames(Math).join(",");
          const prelude = `const {${math}} = Math;\n`;
          const code = `${prelude}
const ctx = self.ctx, canvas = ctx.canvas;
// dwitter.net style:
const S = Math.sin, C = Math.cos, T = Math.tan, R = self.R, c = canvas, x = ctx;
${this.input.value}
typeof draw !== 'undefined' && self.draw(draw);`;
          const fn = new Function("self", code);
          this.stop();
          fn(this);
        }
        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          if (name === "code") {
            this.setCode(newValue);
          }
        }
      }
      customElements.define("canvas-garden", CanvasGarden);
    </script>
    <h2>ðŸŒ± the fourier series II</h2>
    <p>
      in the last post, we've looked at
      <a href="/audio-dsp/fourier.html">the fourier series</a>. it was rather
      formulaic and abstract, so now let's look at the same thing, but visually.
      at first, let's visualise a phasor:
    </p>
    <canvas-garden rows="6" height="200">
      <!--
let draw = (t) => {
c.width=800
x.strokeStyle='white'
drawPhasor(x, c.width/4,c.height/2,80,t)
drawPhasor(x, c.width/4*3,c.height/2,60,-t/2)
}
  -->
    </canvas-garden>
    <details>
      <summary>show drawPhasor source</summary>
      <script>
        function drawPhasor(ctx, cx, cy, r, phase = 0) {
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, 2 * Math.PI);
          ctx.stroke();
          phase = -phase * Math.PI * 2;
          const phaseX = r * (Math.cos(phase) + 1) + cx - r;
          const phaseY = r * (Math.sin(phase) + 1) + cy - r;
          ctx.strokeStyle = "white";
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(phaseX, phaseY);
          ctx.stroke();
          return [phaseX, phaseY];
        }
        window.drawPhasor = drawPhasor;
        codeblock(document.currentScript, 8);
      </script>
    </details>

    <p>
      these circles represent a phasor of a specific frequency (speed of
      rotation) and amplitude (radius of circle).
    </p>
    <p>if we plot the height of the phase against time, we get a sine wave:</p>
    <script>
      function plot(
        fn,
        ctx,
        xrange = [],
        yrange = [],
        color = "white",
        lineWidth = 1
      ) {
        // these 3 functions are very good to know..
        const lerp = (v, min, max) => v * (max - min) + min;
        const invLerp = (v, min, max) => (v - min) / (max - min);
        const remap = (v, vmin, vmax, omin, omax) =>
          lerp(invLerp(v, vmin, vmax), omin, omax);
        // prepare draw context
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        const [cw, ch] = [ctx.canvas.width, ctx.canvas.height - ctx.lineWidth];
        const [x0 = -1, x1 = 1, px0 = 0, px1 = cw] = xrange;
        const [y0 = -1, y1 = 1, py0 = ch, py1 = ctx.lineWidth] = yrange;
        // actual draw logic
        ctx.beginPath();
        for (let px = px0; px < px1; px++) {
          const x = remap(px, px0, px1, x0, x1);
          const y = fn(x);
          const py = remap(y, y0, y1, py0, py1);
          px === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      window.plot = plot;
    </script>

    <canvas-garden rows="16" height="200">
      <!--
let r = 90, f = 1;
let center = c.height/2, bottom = center+r, plotX = r*2+20;
let xrange = [0,Math.PI*2*f,plotX,c.width-20];
let plotW = xrange[3]-xrange[2];
let yrange = [-1,1,center+r,center-r];
let draw = (t) => {
  t=t/4
  c.width=800
  x.strokeStyle='gray'
  let [px,py] = drawPhasor(ctx, r+8,center,r,t*f)
  plot(x => Math.sin(x),x,xrange,yrange)
  x.beginPath();
  x.moveTo(px,py)
  x.strokeStyle='gray'
  x.lineTo(plotX+(t*plotW)%plotW,py)
  x.stroke();
}
  -->
    </canvas-garden>
    <p>now, if we add multiple phasors together, it looks like this:</p>
    <canvas-garden rows="36" height="400">
      <!--
let r = 90, f = 1;
let center = c.height/2, bottom = center+r, plotX = r*2+150;
let xrange = [0,Math.PI*2*f,plotX,c.width-20];
let plotW = xrange[3]-xrange[2];
let yrange = [-1,1,center+r,center-r];

let colors = ['cyan','magenta','yellow']
let phasors = [1, 0.5, 0.25];
let fn = x => phasors.reduce((acc, amp, i) => Math.sin((i+1)*x)*amp+acc,0)
let draw = (t) => {
t=t/4
c.width=800

let px = plotX-r-100, py = center;

phasors.forEach((amp, i) => {
  x.strokeStyle = 'gray'
  const [cx, cy] = drawPhasor(
    x,
    px,
    py,
    r * amp,
    t * (i + 1)
  );
  px = cx;
  py = cy;
});

plot(fn,x,xrange,yrange)
x.beginPath();
x.moveTo(px,py)
x.strokeStyle='gray'
x.lineTo(plotX+(t*plotW)%plotW,py)
x.stroke();
}
  -->
    </canvas-garden>
    <p>
      this visual idea is *not* my own, i've first seen it
      <a href="https://jackschaedler.github.io/circles-sines-signals/">here</a>
    </p>
    <details>
      <summary id="loc">show page source</summary>
      <pre id="pre"></pre>
    </details>
    <p>
      <a href="/">back to garten.salat</a>
    </p>

    <script>
      const html = document.querySelector("html").outerHTML;
      const loc = html.split("\n").length;
      document.querySelector("#pre").textContent = html;
      document.querySelector("#loc").textContent = `show source (${loc} loc)`;
    </script>
  </body>
</html>
