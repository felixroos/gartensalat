<!DOCTYPE html>
<html>
  <head>
    <title>iclc 2025: kabelsalat</title>
    <link
      rel="icon"
      type="image/png"
      href="https://kabel.salat.dev/favicon.png"
    />
    <style>
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        overflow: hidden;
      }
      button {
        background: #222;
        border: 2px solid #555;
        color: white;
        font-size: 1em;
        padding: 2px 4px 4px 4px;
        cursor: pointer;
        &:hover {
          background: #333;
        }
        &:active {
          background: #666;
        }
      }
      node-garden,
      dsp-repl,
      details {
        width: 100%;
        max-width: 800px;
      }
      body {
        background-color: #1d1918;
        margin: auto;
        font-family: monospace;
        font-size: 1.2em;
        color: #edd;
        padding: 20px 8px;
        padding: 0;
      }
      section {
        * {
          flex-shrink: 0;
        }
        position: absolute;
        top: 0;
        left: 0;
        transition: all 0.5s ease-in-out;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 80px 20px;
        width: 100%;
        font-size: 1.5em;
        img {
          max-width: 100%;
        }
        padding-bottom: 500px;
        opacity: 0;
        width: 100%;
        height: 100%;
        /* padding-bottom: 500px; */
        overflow: auto;
        h1,
        h2,
        h3 {
          position: sticky;
          top: 0px;
          padding: 8px;
          background: #1d1918;
          margin-bottom: 20px;
        }
      }
      @font-face {
        font-family: "FontWithASyntaxHighlighter";
        src: url("./FontWithASyntaxHighlighter-Regular.woff2") format("woff2");
      }
      a {
        color: cyan;
        font-size: 1em;
      }
      textarea,
      pre {
        box-sizing: border-box;
        font-family: "FontWithASyntaxHighlighter", monospace;
        padding: 8px;
        font-size: 0.5em;
        border: 0;
        outline: none;
        overflow: auto;
        background-color: #44444490;
        color: white;
        width: 100%;
        margin: 8px 0;
        box-sizing: border-box;
        max-width: 800px;
      }
      #lines {
        height: 200px;
      }
      .logo {
        display: flex;
        top: 0;
        position: absolute;
        align-items: flex-end;
        img {
          height: 50px;
        }
      }
    </style>
    <!-- codeblock -->
    <script>
      // render codeblock from script tag
      let codeblock = (scriptElement, indent = 0) => {
        const script = document.currentScript;
        const pre = document.createElement("pre");
        pre.textContent = getCode(scriptElement, indent);
        script.after(pre);
      };
      function getCode(scriptElement, indent = 0) {
        return scriptElement.innerText
          .split("\n")
          .map((line) => line.slice(indent))
          .filter((x) => x && !x.startsWith("codeblock("))
          .join("\n");
      }
    </script>
    <!-- node-garden -->
    <script>
      class NodeGarden extends HTMLElement {
        static observedAttributes = ["code", "rows"];
        init() {
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "")
              .replace("<!--", "")
              .replace("-->", "")
              .trim() ||
            "";
          this.innerHTML = "";
          const rows = this.getAttribute("rows") ?? 6;

          this.insertAdjacentHTML(
            "beforeend",
            `
      <div style="padding:0;width:100%">
        <div class="viz" style="display:flex;justify-content:center;padding:10px;height:300px"></div>
        <textarea id="code" spellcheck="false" rows="${rows}" style="margin:0;border-bottom:2px solid #222;width:100%;font-size:.8em"></textarea>
        <div style="position:relative">
          <pre class="result">
          </pre>
          <div style="display:flex;position:absolute;right:0;top:0">
            <button style="margin-right:8px" class="run">run</button>
            <button style="margin-right:8px" class="reset">reset</button>
            <button class="step">step</button>
            <button class="contract">-</button>
            <button class="expand">+</button>
          </div>
        </div>
        <details>
          <summary>show steps</summary>
          <pre class="steps"></pre>
        </details>

      </div>`
          );
          // repl logic
          const input = this.querySelector("textarea");
          this.result = this.querySelector(".result");
          this.steps = this.querySelector(".steps");
          this.vizContainer = this.querySelector(".viz");
          this.runButton = this.querySelector(".run");
          this.stepButton = this.querySelector(".step");
          this.resetButton = this.querySelector(".reset");
          this.contractButton = this.querySelector(".contract");
          this.expandButton = this.querySelector(".expand");
          input.value = code;
          this.input = input;
          this.reset();

          this.stepButton.addEventListener("click", () => this.step());
          this.runButton.addEventListener("click", () => this.update());
          this.resetButton.addEventListener("click", () => this.reset());
          this.contractButton.addEventListener("click", () => this.contract());
          this.expandButton.addEventListener("click", () => this.expand());

          input.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              this.update();
            } else if ((e.ctrlKey || e.altKey) && e.key === ".") {
              e.preventDefault();
              this.stop();
            }
          });
        }
        setCode(code) {
          this.code = code;
          this.input.value = code;
          this.update();
        }
        reset() {
          this.results = [];
          this.update();
          this.results = []; // maybe this is not needed..
          this.currentNode = null;
          this.visited = [];
          delete this.stepper;
          this.steps.innerText = "// click step to start walking";
          // this.render();
        }
        render() {
          renderNode(this.node, this.vizContainer);
        }
        nodeColor(node) {
          const cid = this.currentNode?.id;
          if (node.id === cid) {
            return "magenta";
          }
          if (this.results[node.id] !== undefined) {
            return "cyan";
          }
          if (this.visited.find((v) => v.id === node.id)) {
            return "yellow";
          }
          return "white";
        }
        renderStepped() {
          const cid = this.currentNode?.id;
          renderNode(
            this.node,
            this.vizContainer,
            (node) => {
              node.color = this.nodeColor(node);
              const n = this.nodes[node.id];
              return node;
            },
            (edge) => {
              const source = this.nodes[edge.source];
              const target = this.nodes[edge.target];
              const argIndex = target.ins.findIndex(
                (input) => input.id === edge.source
              );
              const sourceColor = this.nodeColor(source);
              const targetColor = this.nodeColor(target);

              if (edge.target === cid) {
                edge.color = "magenta";
              } else if (sourceColor === "cyan") {
                edge.color = "cyan";
              } else if (this.visited.find((v) => v.id === edge.target)) {
                edge.color = "yellow";
              }
              const hasResult = this.results[edge.source] !== undefined;
              if (!hasResult && ["magenta"].includes(edge.color)) {
                edge.label = "?";
              } else if (["yellow"].includes(edge.color)) {
                edge.label = "?";
              } else if (edge.target <= cid || cid === undefined) {
                edge.label = target.args?.[argIndex] ?? "";
              } else {
                edge.label = this.results[edge.source] ?? "";
              }
              return edge;
            }
          );
        }
        evaluate() {
          const fn = new Function("self", this.input.value);
          this.node = fn(this);
          this.nodes = Array.from(topoSort(this.node));
          this.nodes.forEach((node, i) => {
            node.id = i;
          });
        }
        async update() {
          // this.results = []; // clear state
          expansions = 0;
          this.evaluate();
          this.render();
          this.result.innerText = `= ${this.node.run([], this.results)}`;
        }
        step() {
          if (!this.stepper) {
            this.visited = [];
            //this.results = []; // uncomment to disable feedback
            this.stepper = this.node.step(this.visited, this.results);
            this.result.innerText = "= ?";
          }
          const next = this.stepper.next();
          this.currentNode = next.value;
          const cid = this.currentNode?.id;

          this.renderStepped();
          const calculations =
            this.results
              .map((result, i) => {
                const n = this.nodes[i];
                if (!this.visited.includes(n) || n.id >= cid) {
                  return "";
                }
                //const output = result
                const output = cid < i ? "?" : result ?? "??";
                return `r[${i}] = ${n.type}(${n.ins
                  .map((input, i) =>
                    input instanceof Node ? `r[${input.id}]` : input
                  )
                  .join(", ")}) = ${output}`;
              })
              .filter(Boolean)
              .join("\n") || `// searching computable nodes`;
          this.steps.innerText = calculations;
          if (!this.currentNode) {
            this.result.innerText = `= ${
              this.results[this.results.length - 1]
            }`;
            delete this.stepper;
            return;
          }
        }
        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          if (name === "code") {
            this.setCode(newValue);
          }
        }
        contract() {
          this.renderExpansion(expansion - 1);
        }
        expand() {
          this.renderExpansion(expansion + 1);
        }
        renderExpansion(_expansion = 0) {
          expansion = Math.max(_expansion, 0);
          expansion = Math.min(expansion, nextExpansion);
          expansions = 0;
          this.evaluate();
          let nodes = Array.from(topoSort(this.node));
          renderNode(this.node, this.vizContainer, (gvnode) => {
            const node = nodes[gvnode.id];
            if (node.type === "poly") {
              gvnode.color = "orchid";
            } else if (node.ins.find((input) => input?.type === "poly")) {
              gvnode.color = "cyan";
            }
            return gvnode;
          });

          if (!nodes.slice(0, -1).find((node) => node.type === "poly")) {
            nextExpansion = expansion; // cannot step more
            console.log("done expanding");
          } else {
            nextExpansion = expansion + 1; // at least one more...
          }
        }
      }
      customElements.define("node-garden", NodeGarden);
    </script>
    <!-- graphviz -->
    <script>
      function gvjson2dot(json) {
        const { nodes, edges } = json;
        let renderProps = (props) =>
          `[${Object.entries(props)
            .map(([key, value]) => `${key}="${value}"`)
            .join(",")}]`;
        return `digraph {
            bgcolor="transparent";
            rankdir="LR";
            node [penwidth=4];
            edge [penwidth=2];
            ${nodes
              .map((node) => `  "${node.id}" ${renderProps(node)}`)
              .join("\n")}
            ${edges
              .map(
                (edge) =>
                  `  ${edge.source} -> ${edge.target} ${renderProps(edge)}`
              )
              .join("\n")}
            }`;
      }
      function node2gvjson(graph, editNode, editEdge) {
        let dfs = (node, fn, visited = []) => {
          if (typeof node !== "object") {
            return node;
          }
          visited.push(node);
          node.ins = node.ins.map((input) => {
            if (visited.includes(input)) {
              return input;
            }
            return dfs(input, fn, visited);
          });
          node = fn(node, visited);
          return node;
        };
        const nodes = [],
          edges = [];
        let style = {
          color: "white",
          fontcolor: "white",
          fontsize: "10",
          fontname: "monospace",
        };
        dfs(graph, (node) => {
          node.id = nodes.length;
          const label = `${node.type} ${node.ins
            .map((input) =>
              typeof input === "object"
                ? "_"
                : Math.round(input * 10000) / 10000
            )
            .join(" ")}`;
          let gvnode = {
            id: node.id,
            label,
            ordering: "in",
            width: "0.5",
            height: "0.4",
            ...style,
          };
          if (editNode) {
            gvnode = editNode(gvnode);
          }
          nodes.push(gvnode);
          for (let i in node.ins) {
            if (typeof node.ins[i] !== "object") {
              continue;
            }
            if (node.ins[i].id === undefined) {
              console.log("undefined source id", node.ins[i]);
            }
            let gvedge = {
              label: "",
              id: edges.length,
              source: node.ins[i].id ?? "whuuuat",
              target: node.id,
              directed: "true",
              ...style,
            };
            if (editEdge) {
              gvedge = editEdge(gvedge);
            }
            edges.push(gvedge);
          }
          return node;
        });
        return { nodes, edges };
      }
      function node2dot(node, editNode, editEdge) {
        const flat = node2gvjson(node, editNode, editEdge);
        const dot = gvjson2dot(flat);
        return dot;
      }
      async function renderDot(dot, container) {
        // this breaks my rule of self-contained html :/
        // but graphviz is just so good..
        // i don't want to segway into graph layouting rn...
        // download the file here: https://unpkg.com/@hpcc-js/wasm@2.18.0/dist/graphviz.js
        // sorry if you're living in 2051 and npm has collapsed already..
        const { Graphviz } = await import("./graphviz.js");
        const graphvizLoaded = Graphviz.load();
        const graphviz = await graphvizLoaded;
        const svg = await graphviz.layout(dot, "svg", "dot", {});
        const base64 = btoa(unescape(encodeURIComponent(svg)));
        const dataUrl = `data:image/svg+xml;base64,${base64}`;
        const img = document.createElement("img");
        img.src = dataUrl;
        img.style.maxHeight = "200px";
        img.style.width = "600px";
        container.innerText = "";
        container.appendChild(img);
      }
      function renderNode(node, container, editNode, editEdge) {
        const dot = node2dot(node, editNode, editEdge);
        return renderDot(dot, container);
      }
    </script>
    <!-- Node -->
    <script id="node-class">
      let Node = class {
        constructor(type, ins, update) {
          this.type = type;
          this.ins = ins;
          this.update = update;
        }
      };
    </script>

    <template class="dsp-worklet">
      <script>
        class DspProcessor extends AudioWorkletProcessor {
          dsp = () => {};
          l = 0;
          r = 0;
          SR = sampleRate;
          ISR = 1 / sampleRate;
          constructor() {
            super();
            this.t = 0;
            this.S = 0;
            this.active = true;
            this.framebuffer = new Float32Array(Math.floor(sampleRate / 30));
            this.msg = {
              framebuffer: this.framebuffer,
            };
            globalThis.$ = this;
            this.port.onmessage = (e) => {
              const msg = e.data;
              if (msg && msg.code) {
                //new Function("$", msg.code)(this);
                new Function(msg.code)();
              } else if (msg === "stop") {
                this.active = false;
              }
            };
          }
          process(inputs, outputs, parameters) {
            const output = outputs[0];
            for (let i = 0; i < output[0].length; i++) {
              this.dsp(this.t / sampleRate);
              output[0][i] = this.l;
              output[1][i] = this.r;
              this.t++;
              this.S = this.t * this.ISR;
              this.framebuffer[this.t % this.framebuffer.length] = this.l;
              if (this.t % this.framebuffer.length === 0 && this.t > 0) {
                this.port.postMessage(this.msg);
              }
            }
            return this.active;
          }
        }
      </script>
    </template>
    <!-- dsp-repl -->
    <script>
      const ctx = new AudioContext();
      // init audio context
      document.addEventListener("click", function firstClick() {
        ctx.resume(); // autoply policy
        document.removeEventListener("click", firstClick);
      });

      const _lerp = (v, min, max) => v * (max - min) + min;
      const invLerp = (v, min, max) => (v - min) / (max - min);
      const remap = (v, vmin, vmax, omin, omax) =>
        _lerp(invLerp(v, vmin, vmax), omin, omax);

      class DSPRepl extends HTMLElement {
        static observedAttributes = ["code", "rows", "next"];
        worklet;
        init() {
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "").replace("<!--", "").replace("-->", "").trim();

          const rows = this.getAttribute("rows") ?? 4;
          if (!code) {
            return;
          }
          this.innerHTML = "";
          this.insertAdjacentHTML(
            "beforeend",
            `<div style="border:2px solid #222;padding:0;">
            
            <textarea id="code" spellcheck="false" rows="${rows}"></textarea>
            <div style="user-select:none;cursor:pointer">
            <button class="play">run</button> <button class="stop">stop</button>
            </div>
            <canvas width="400" height="80"></canvas>
            <div class="viz" style="display:flex;justify-content:center;padding:10px;height:300px"></div>
            </div>
              `
          );
          // draw logic
          this.vizContainer = this.querySelector(".viz");
          this.canvas = this.querySelector("canvas");
          this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;
          this.canvas.height =
            this.canvas.clientHeight * window.devicePixelRatio;
          this.drawContext = this.canvas.getContext("2d");
          this.drawSilence(this.drawContext);

          // repl logic
          const input = this.querySelector("textarea");
          input.value = code;
          input.style = "margin:0;border-bottom:2px solid #222";
          this.input = input;

          this.querySelector(".play").onclick = () => this.update(input.value);
          this.querySelector(".stop").onclick = () => this.stop();
          input.addEventListener("keydown", async (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              const hash = btoa(input.value);
              let urlCode = window.location.hash.slice(1);
              this.update(input.value);
            }
            if ((e.ctrlKey || e.altKey) && e.code === "Period") {
              e.preventDefault();
              this.stop();
            }
          });
        }
        async initWorklet() {
          if (this.worklet) {
            return;
          }
          await ctx.resume();
          this.worklet = await this.runWorklet(ctx, this.input.value);
          this.worklet.port.onmessage = (e) => {
            if (e.data.framebuffer) {
              requestAnimationFrame(() => this.drawBuffer(e.data.framebuffer));
            } else if (e.data.viz) {
              const node = JSON.parse(e.data.viz);
              renderNode(node, this.vizContainer);
              // this.vizContainer.style.display = "block";
            }
          };
        }

        async update(code) {
          await this.initWorklet();
          /* console.log("update:::", code); */
          if (this.getAttribute("next")) {
            globalThis.$ = this;
            const fn = new Function(code)();
          } else {
            this.worklet.port.postMessage({ code });
          }
        }
        stop() {
          this.worklet?.disconnect();
          this.worklet?.port.postMessage("stop");
          delete $.n;
          delete $.nodes;
          this.worklet = undefined;
        }

        async runWorklet(ac) {
          const name = `worklet-${Date.now()}`;
          const math = Object.getOwnPropertyNames(Math).join(",");
          let prelude = `const {${math}} = Math;\nObject.assign(globalThis,{${math}})\n`;
          // add dsp scripts
          document
            .querySelector("template.dsp-prelude")
            .content.querySelectorAll("script")
            .forEach((script) => {
              prelude += script.textContent;
            });

          let workletCode = document
            .querySelector("template.dsp-worklet")
            .content.querySelector("script").textContent;

          workletCode = `${prelude}\n${workletCode}\nregisterProcessor('${name}', DspProcessor);`;

          await ac.resume();
          const dataURL = `data:text/javascript;base64,${btoa(workletCode)}`;
          await ac.audioWorklet.addModule(dataURL);
          const node = new AudioWorkletNode(ac, name, {
            outputChannelCount: [2],
          });
          node.connect(ac.destination);
          return node;
        }

        drawBuffer(samples) {
          const ctx = this.drawContext;
          const canvas = ctx.canvas;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.lineWidth = 2;
          ctx.strokeStyle = "white";
          let x0 = 1;
          let x1 = samples.length;
          let y0 = -1;
          let y1 = 1;
          let px0 = 0;
          let px1 = ctx.canvas.width;
          let py0 = ctx.canvas.height - ctx.lineWidth;
          let py1 = ctx.lineWidth;
          ctx.beginPath();
          for (let px = 0; px < ctx.canvas.width; px++) {
            const x = remap(px, px0, px1, x0, x1);
            const y = samples[Math.floor(x)];
            const py = remap(y, y0, y1, py0, py1);
            px === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
          }
          ctx.stroke();
        }

        drawSilence(ctx, color = "white", lineWidth = 2) {
          const canvas = ctx.canvas;
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height / 2);
          ctx.lineTo(canvas.width, canvas.height / 2);
          ctx.stroke();
        }

        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          this.init();
        }
      }
      customElements.define("dsp-repl", DSPRepl);
    </script>
    <template class="dsp-prelude">
      <!-- Node -->
      <script>
        // https://garten.salat.dev/kabelsalat/graph-computation.html
        class DspNode {
          constructor(type, ins, update, compileSelf) {
            this.type = type;
            update && (this.update = update);
            compileSelf && (this.compileSelf = compileSelf);

            // multichannel expansion
            let maxExpansions = 0;
            this.ins = ins.map((input) => {
              input = this.parseInput(input);
              if (input.type === "poly") {
                maxExpansions = Math.max(maxExpansions, input.ins.length);
              }
              return input;
            });
            if (maxExpansions > 0) {
              this.type = "poly";
              this.update = (...args) => args;
              this.compileSelf = (r, args) =>
                `$.l=${args[0]}*0.3;$.r=${args[1] || args[0]}*0.3;`;
              // make mono if only one channel

              this.ins = Array(maxExpansions)
                .fill(0)
                .map((_, i) => {
                  const clone = new this.constructor(
                    type,
                    [],
                    update,
                    compileSelf
                  );
                  clone.ins = ins.map((input) => {
                    input = clone.parseInput(input);
                    if (input.type === "poly") {
                      return input.ins[i % input.ins.length];
                    }
                    return input;
                  });
                  return clone;
                });
            }
          }
          run() {
            const args = this.ins.map((input) => {
              if (input instanceof Node) {
                return input.run();
              }
              return input;
            });
            return this.update(...args);
          }
        }

        globalThis.Node = DspNode;
        Node.prototype.parseInput = function (input) {
          if (typeof input === "function") {
            input = input(this); // lambda feedback
          }
          // multichannel expansion
          if (Array.isArray(input)) {
            input = poly(...input);
          }
          return input;
        };
        Node.prototype.compile = function (memory) {
          let nodes = Array.from(topoSort(this));
          // console.log(memory.join("\n"));
          let r = memory ? memory : Array(nodes.length).fill(0);
          const getRef = (input) =>
            typeof input !== "object" ? input : `r[${nodes.indexOf(input)}]`;
          let lines = [];
          for (let id in nodes) {
            const node = nodes[id];
            const args = node.ins.map(getRef);
            const ref = getRef(node);
            if (!node.compileSelf) {
              lines.push(`${ref} = n[${id}].update(${args.join(",")})`);
            } else {
              lines.push(node.compileSelf(ref, args, node, id));
            }
            lines[lines.length - 1] += ` // ${node.type}`;
          }
          const last = getRef(nodes[nodes.length - 1]);
          // lines.push(`return ${last}`);
          const code = lines.join("\n");
          console.log("-------compiled--------");
          console.log(code);
          const update = new Function("n", "r", code);
          const node = new Node("compiled", [], () => update(nodes, r));
          return node;
        };
        Node.prototype.viz = function () {
          try {
            $.port.postMessage({ viz: JSON.stringify(this) });
          } catch (err) {
            console.warn("non serializable node. probably because of feedback");
          }
          return this;
        };
        globalThis.register = (type, getNode) => {
          Node.prototype[type] = function (...args) {
            return getNode(this, ...args);
          };
          return getNode;
        };
        globalThis.registerFn = (type, update) =>
          register(type, (...args) => new Node(type, args, update));

        globalThis.registerClass = (type, NodeClass) =>
          register(type, (...args) => new NodeClass(type, args));

        globalThis.registerRaw = (type, compileSelf) =>
          register(type, (...args) => {
            const argNames = Array.from(
              { length: args.length },
              (_, i) => `a${i}`
            );
            const body = `${compileSelf("let v", argNames)}; return v;`;
            const update = new Function(...argNames, body);
            return new Node(type, args, update, compileSelf);
          });
        globalThis.poly = registerFn("poly", (...args) => args);
      </script>
      <!-- topoSort -->
      <script>
        // https://garten.salat.dev/kabelsalat/graph-compilation.html
        // sort nodes by dependencies (using generator function to be able to step through)
        function* topoSort(node, visited = new Set()) {
          if (!(node instanceof Node) || visited.has(node)) {
            return; // constant values or already visited nodes
          }
          visited.add(node);
          for (let input of node.ins) {
            yield* topoSort(input, visited);
          }
          yield node;
        }
      </script>
      <script id="play-method">
        Node.prototype.play = function () {
          // the last node must be poly to assign to $.l when compiled
          const out = this.type === "poly" ? this : n([this]);
          if (out.ins.length > 2) {
            console.warn("more than 2 channels! only using first 2");
          }
          out.viz();
          let compiled = out.compile();
          console.log("compiled", compiled);
          $.dsp = () => compiled.run();
          return compiled;
        };
        Node.prototype.out = Node.prototype.play;
      </script>
      <script id="collect-method">
        Node.prototype.collect = function (max = 1) {
          $.nodes ??= [];
          $.nodes.push(this);
          $.nodes = $.nodes.slice(-max);
          return add(...$.nodes);
        };
      </script>
      <script id="group-method">
        Node.prototype.group = function (max = 1, fadeIn = 0, fadeOut = 0.1) {
          $.nodes ??= [];
          let len = $.nodes.length;
          // fade out / retire old nodes

          $.nodes = $.nodes.reduce((acc, node, i) => {
            // assumes nodes is poly node with at least 1 channel
            const in0 = node.ins[0];
            //console.log("in0", in0);
            if (in0.type === "fadeout" && in0.done) {
              return acc; // omit already silent node
            }
            if (in0.type === "fadein" && in0.done) {
              node.ins = node.ins.map((input) => input.ins[0]);
            }
            if (in0.type !== "fadeout" && len - i >= max) {
              if (!fadeOut) {
                return acc;
              }
              node = fadeout(node, fadeOut);
            }
            acc.push(node);
            return acc;
          }, []);

          // fade in new node
          let node = fadeIn ? this.fadein(fadeIn) : this;
          // make sure node is always poly (simplifies checks in reducer above)
          if (node.type !== "poly") {
            node = poly(node);
          }
          $.nodes.push(node);
          return add(...$.nodes);
        };
        Node.prototype.spawn = function (max = 1, fadeIn = 1, fadeOut = 1) {
          return this.group(max, fadeIn, fadeOut).play();
        };
      </script>
      <script id="fade">
        // maybe these could be combined into a single Node
        class FadeIn /* extends Node  */ {
          start = $.S;
          done = false;
          update(input, fadeTime = 1) {
            const progress = ($.S - this.start) / fadeTime;
            if (progress >= 1) {
              this.done = true;
              return input;
            }
            const gain = Math.min(1, progress);
            return input * gain;
          }
        }
        globalThis.FadeIn = FadeIn;
        globalThis.fadein = registerClass("fadein", FadeIn);
        class FadeOut /* extends Node  */ {
          start = $.S;
          done = false;
          update(input, fadeTime = 1) {
            this.init = true;
            const progress = ($.S - this.start) / fadeTime;
            if (progress >= 1) {
              this.done = true;
              return 0;
            }
            const gain = 1 - Math.min(1, progress);
            return input * gain;
          }
        }
        globalThis.FadeOut = FadeOut;
        globalThis.fadeout = registerClass("fadeout", FadeOut);
      </script>
      <script>
        const ISR = 1 / sampleRate;
        // https://garten.salat.dev/audio-dsp/oscillators.html
        class SineOsc /* extends Node */ {
          phase = 0;
          update(freq) {
            const value = Math.sin(this.phase * 2 * Math.PI);
            this.phase = (this.phase + freq / sampleRate) % 1;
            return value;
          }
        }
        globalThis.SineOsc = SineOsc;
        globalThis.sine = registerClass("sine", SineOsc);

        class ZawOsc /* extends Node  */ {
          phase = 0;
          update(freq) {
            this.phase += ISR * freq;
            return (this.phase % 1) * 2 - 1;
          }
        }
        globalThis.ZawOsc = ZawOsc;
        globalThis.zaw = registerClass("zaw", ZawOsc);

        function polyBlep(t, dt) {
          // 0 <= t < 1
          if (t < dt) {
            t /= dt;
            // 2 * (t - t^2/2 - 0.5)
            return t + t - t * t - 1;
          }
          // -1 < t < 0
          if (t > 1 - dt) {
            t = (t - 1) / dt;
            // 2 * (t^2/2 + t + 0.5)
            return t * t + t + t + 1;
          }
          // 0 otherwise
          return 0;
        }
        class SawOsc /* extends Node  */ {
          //phase = Math.random();
          phase = 0;
          update(freq) {
            const dt = freq / sampleRate;
            let p = polyBlep(this.phase, dt);
            let s = 2 * this.phase - 1 - p;
            this.phase += dt;
            if (this.phase > 1) {
              this.phase -= 1;
            }
            return s;
          }
        }
        globalThis.SawOsc = SawOsc;
        globalThis.saw = registerClass("saw", SawOsc);

        globalThis.mix = register("mix", (input, channels = 1) => {
          if (![1, 2].includes(channels)) {
            channels = 2;
            console.warn(
              "mix only supports 1 or 2 channels atm.. falling back to 2"
            );
          }
          if (input.type !== "poly") {
            return input;
          }
          if (channels === 2) {
            const panned = input.ins.map((channel, i, ins) => {
              // we can do this at eval time: channels are fixed!
              const pos = (i / (ins.length - 1)) * 2 - 1;
              const deg = ((pos + 1) * Math.PI) / 4;
              const stereo = channel.mul([Math.cos(deg), Math.sin(deg)]);
              return stereo;
            });
            return add(...panned);
          }
          return add(...input.ins);
        });

        class Lpf /* extends Node  */ {
          s0 = 0;
          s1 = 0;
          update(s, cutoff, resonance = 0) {
            // Out of bound values can produce NaNs
            cutoff = Math.min(cutoff, 1);
            resonance = Math.max(resonance, 0);
            var c = Math.pow(0.5, (1 - cutoff) / 0.125);
            var r = Math.pow(0.5, (resonance + 0.125) / 0.125);
            var mrc = 1 - r * c;
            var v0 = this.s0;
            var v1 = this.s1;
            // Apply the filter to the sample
            v0 = mrc * v0 - c * v1 + c * s;
            v1 = mrc * v1 + c * v0;
            s = v1;
            this.s0 = v0;
            this.s1 = v1;
            return s;
          }
        }
        globalThis.Lpf = Lpf;
        globalThis.lpf = registerClass("lpf", Lpf);

        class PulseOsc /* extends Node  */ {
          phase = 0;
          update(freq, duty = 0.5) {
            this.phase += ISR * freq;
            let cyclePos = this.phase % 1;
            return cyclePos < duty ? 1 : -1;
          }
        }
        globalThis.PulseOsc = PulseOsc;
        globalThis.pulse = registerClass("pulse", PulseOsc);

        class Dust /* extends Node  */ {
          update = (density) =>
            Math.random() < density * ISR ? Math.random() : 0;
        }
        globalThis.Dust = Dust;
        globalThis.dust = registerClass("dust", Dust);

        class Impulse /* extends Node  */ {
          phase = 1;
          update(freq) {
            this.phase += ISR * freq;
            let v = this.phase >= 1 ? 1 : 0;
            this.phase = this.phase % 1;
            return v;
          }
        }
        globalThis.Impulse = Impulse;
        globalThis.impulse = registerClass("impulse", Impulse);

        globalThis.noise = registerRaw(
          "noise",
          (r) => `${r} = Math.random() * 2 - 1`
        );

        class Hold /* extends Node  */ {
          value = 0;
          trigSgn = false;
          update(input, trig) {
            if (!this.trigSgn && trig > 0) this.value = input;
            this.trigSgn = trig > 0;
            return this.value;
          }
        }
        globalThis.Hold = Hold;
        globalThis.hold = registerClass("hold", Hold);

        function lerp(x, y0, y1) {
          if (x >= 1) return y1;

          return y0 + x * (y1 - y0);
        }

        class ADSR /* extends Node  */ {
          state = "off";
          startTime = 0;
          startVal = 0;

          update(gate, attack, decay, susVal, release) {
            let curTime = $.S; // $.S = time in seconds
            switch (this.state) {
              case "off": {
                if (gate > 0) {
                  this.state = "attack";
                  this.startTime = curTime;
                  this.startVal = 0;
                }
                return 0;
              }
              case "attack": {
                let time = curTime - this.startTime;
                if (time > attack) {
                  this.state = "decay";
                  this.startTime = curTime;
                  return 1;
                }
                return lerp(time / attack, this.startVal, 1);
              }
              case "decay": {
                let time = curTime - this.startTime;
                let curVal = lerp(time / decay, 1, susVal);
                if (gate <= 0) {
                  this.state = "release";
                  this.startTime = curTime;
                  this.startVal = curVal;
                  return curVal;
                }
                if (time > decay) {
                  this.state = "sustain";
                  this.startTime = curTime;
                  return susVal;
                }
                return curVal;
              }
              case "sustain": {
                if (gate <= 0) {
                  this.state = "release";
                  this.startTime = curTime;
                  this.startVal = susVal;
                }
                return susVal;
              }
              case "release": {
                let time = curTime - this.startTime;
                if (time > release) {
                  this.state = "off";
                  return 0;
                }
                let curVal = lerp(time / release, this.startVal, 0);
                if (gate > 0) {
                  this.state = "attack";
                  this.startTime = curTime;
                  this.startVal = curVal;
                }
                return curVal;
              }
            }
            throw "invalid envelope state";
          }
        }
        globalThis.ADSR = ADSR;
        globalThis.adsr = registerClass("adsr", ADSR);

        globalThis.ad = register("ad", (gate = 0, attack = 0.02, decay = 0.1) =>
          adsr(gate, attack, decay, 0, decay)
        );
        /*
        impulse(1).ad(.1).mul(sine(200))
.add(x=>x.delay(.1).mul(.8))
.play()*/
        const MAX_DELAY_TIME = 10;
        class Delay /* extends Node  */ {
          writeIdx = 0;
          readIdx = 0;
          buffer = new Float32Array(MAX_DELAY_TIME * sampleRate); // .fill(0)
          write(s, delayTime) {
            this.writeIdx = (this.writeIdx + 1) % this.buffer.length;
            this.buffer[this.writeIdx] = s;
            // Calculate how far in the past to read
            let numSamples = Math.min(
              Math.floor(sampleRate * delayTime),
              this.buffer.length - 1
            );
            this.readIdx = this.writeIdx - numSamples;
            // If past the start of the buffer, wrap around
            if (this.readIdx < 0) this.readIdx += this.buffer.length;
          }
          update(input, delayTime) {
            this.write(input, delayTime);
            return this.buffer[this.readIdx];
          }
        }
        globalThis.Delay = Delay;
        globalThis.delay = registerClass("delay", Delay);

        class Fold /* extends Node  */ {
          update(input = 0, rate = 0) {
            if (rate < 0) rate = 0;
            rate = rate + 1;
            input = input * rate;
            return (
              4 *
              (Math.abs(0.25 * input + 0.25 - Math.round(0.25 * input + 0.25)) -
                0.25)
            );
          }
        }
        globalThis.Fold = Fold;
        globalThis.fold = registerClass("fold", Fold);

        let perc = register("perc", (gate, decay) => gate.adsr(0, 0, 1, decay));

        class Lag /* extends Node  */ {
          lagUnit = 4410;
          s = 0;
          update(input, rate) {
            // Remap so the useful range is around [0, 1]
            rate = rate * this.lagUnit;
            if (rate < 1) rate = 1;
            this.s += (1 / rate) * (input - this.s);
            return this.s;
          }
        }
        globalThis.Lag = Lag;
        globalThis.lag = registerClass("lag", Lag);

        class Slew /* extends Node  */ {
          last = 0;
          update(input, up, dn) {
            const upStep = up * ISR;
            const downStep = dn * ISR;
            let delta = input - this.last;
            if (delta > upStep) {
              delta = upStep;
            } else if (delta < -downStep) {
              delta = -downStep;
            }
            this.last += delta;
            return this.last;
          }
        }
        globalThis.Slew = Slew;
        globalThis.slew = registerClass("slew", Slew);

        globalThis.applyDistortion = (x, amount) => {
          amount = Math.min(Math.max(amount, 0), 1);
          amount -= 0.01;
          var k = (2 * amount) / (1 - amount);
          var y = ((1 + k) * x) / (1 + k * Math.abs(x));
          return y;
        };
        globalThis.distort = registerRaw(
          "distort",
          (r, a) => `${r} = applyDistortion(${a.join(",")})`
        );
        globalThis.hpf = register("hpf", (input, cutoff, resonance = 0) =>
          input.sub(input.lpf(cutoff, resonance))
        );

        class Sequence /* extends Node  */ {
          clockSgn = true;
          step = 0;
          first = true;
          update(clock, ...ins) {
            if (!this.clockSgn && clock > 0) {
              this.step = (this.step + 1) % ins.length;
              this.clockSgn = clock > 0;
              return 0; // set first sample to zero to retrigger gates on step change...
            }
            this.clockSgn = clock > 0;
            return ins[this.step];
          }
        }
        globalThis.Sequence = Sequence;
        globalThis.seq = registerClass("seq", Sequence);
        globalThis.midinote = registerRaw(
          "midinote",
          (r, [note]) => `${r} = (2 ** ((${note} - 69) / 12) * 440)`
        );

        globalThis.midi2freq = (midi) => Math.pow(2, (midi - 69) / 12) * 440;

        globalThis.range = registerRaw(
          "range",
          (r, [bip, a, b]) => `${r} = ((${bip} + 1) / 2) * (${b} - ${a}) + ${a}`
        );
        /* let log = registerNode("log", (r, a) => `${r} = Math.log(${a})`);
        let exp = registerNode("exp", (r, a) => `${r} = Math.exp(${a})`);
        let sin = registerNode("sin", (r, a) => `${r} = Math.sin(${a})`);
        let cos = registerNode("cos", (r, a) => `${r} = Math.cos(${a})`); */

        globalThis.unipolar = registerRaw(
          "unipolar",
          (r, [bip]) => `${r} = (${bip}+1)/2;`
        );
        globalThis.bipolar = registerRaw(
          "bipolar",
          (r, [uni]) => `${r} = ${uni}*2-1;`
        );

        globalThis._rangex = (sig, min, max) => {
          let logmin = Math.log(min);
          let range = Math.log(max) - logmin;
          const unipolar = (sig + 1) / 2;
          return Math.exp(unipolar * range + logmin);
        };
        globalThis.rangex = registerRaw(
          "rangex",
          (r, args) => `${r} = _rangex(${args.join(",")})`
        );

        globalThis.pan = register("pan", (input, pos) => {
          // (pos+1)/2 * PI/2 = (pos+1) * PI * 0.25
          return input;
          /* pos = add(pos, 1).mul(Math.PI, 0.25);
          return input.mul([Math.cos(pos), Math.sin(pos)]); */
        });

        globalThis.add = registerRaw("add", (r, a) => `${r} = ${a.join("+")}`);
        globalThis.sub = registerRaw("sub", (r, a) => `${r} = ${a.join("-")}`);
        globalThis.mul = registerRaw("mul", (r, a) => `${r} = ${a.join("*")}`);
        globalThis.div = registerRaw("div", (r, a) => `${r} = ${a.join("/")}`);
        globalThis.mod = registerRaw("mod", (r, a) => `${r} = ${a.join("%")}`);
        globalThis.n = registerRaw("n", (r, x) => `${r} = ${x}`);

        Node.prototype.apply = function (x) {
          return x(this);
        };
        // sine(240).raw(([n]) => `${n}/16`)
        /* let raw = register("raw", (...args) => {
          const compileSelf = args[args.length - 1];
          return new Node("raw", args.slice(0, -1), null, compileSelf);
        }); */
        /* let raw = (type, compileSelf) =>
          register((...args) => new Node(type, args, null, compileSelf));
        let raw = registerRaw('raw', ()) */
        // sine(100).raw((arg) => `${arg}/2`)
        Object.assign(globalThis, {
          Node,
        });
      </script>
    </template>
    <script>
      function register(type, getNode) {
        // register method for chaining
        Node.prototype[type] = function (...args) {
          //return getNode(type, [this, ...args]);
          return getNode(this, ...args);
        };
        // return function for unchained calls
        //return (...args) => getNode(type, args);
        return getNode;
      }
      let registerFn = (type, update) =>
        //register(type, (type, args) => new Node(type, args, update));
        register(type, (...args) => new Node(type, args, update));

      let registerUgen = (type, name) =>
        //register(type, (type, args) => new Node(type, args, update));
        register(
          type,
          (...args) =>
            new Node(type, args, null, null, (r) => `${r} = new ${name}()`)
        );

      const registerRaw = (type, compileSelf) =>
        register(type, (...args) => {
          const argNames = Array.from(
            { length: args.length },
            (_, i) => `a${i}`
          );
          const body = `${compileSelf("let v", argNames)}; return v;`;
          const update = new Function(...argNames, body);
          return new Node(type, args, update, compileSelf);
        });
    </script>
    <script id="node-feedback">
      Node = class {
        constructor(type, ins, update) {
          this.type = type;
          this.ins = this.ins.map((input) => this.parseInput(input));
          this.update = update;
        }
      };
      Node.prototype.parseInput = function (input) {
        if (typeof input === "function") {
          return input(this);
        }
        return input;
      };
    </script>
    <script id="node-expansion">
      let poly = registerFn("poly", (...args) => args);

      // these variables are for the stepwise viz (very dirty hack)
      let expansions = 0;
      let expansion = -1;
      let nextExpansion = 1;

      // this is the "full" version
      Node = class {
        /* constructor(type, ins, update) {
          this.type = type;
          this.update = update;
          let maxExpansions = 0;
          this.ins = ins.map((input) => {
            input = this.parseInput(input);
            if (input.type === "poly") {
              maxExpansions = Math.max(maxExpansions, input.ins.length);
            }
            return input;
          });
          if (expansion !== -1 && expansions >= expansion) {
            return; // dirty hack for viz (not needed otherwise)
          }
          if (maxExpansions > 0) {
            expansions++; // dirty hack for viz (not needed otherwise)
            // multichannel expansion
            this.type = "poly";
            this.update = (...args) => args;
            this.ins = Array(maxExpansions)
              .fill(0)
              .map((_, i) => {
                const clone = new this.constructor(type, [], update);
                clone.ins = ins.map((input) => {
                  input = clone.parseInput(input);
                  if (input.type === "poly") {
                    return input.ins[i % input.ins.length];
                  }
                  return input;
                });
                return clone;
              });
          }
        } */

        constructor(type, ins, update, compileSelf, compileSetup) {
          this.type = type;
          update && (this.update = update);
          compileSelf && (this.compileSelf = compileSelf);
          compileSetup && (this.compileSetup = compileSetup);

          // multichannel expansion
          let maxExpansions = 0;
          this.ins = ins.map((input) => {
            input = this.parseInput(input);
            if (input.type === "poly") {
              maxExpansions = Math.max(maxExpansions, input.ins.length);
            }
            return input;
          });
          if (expansion !== -1 && expansions >= expansion) {
            return; // dirty hack for viz (not needed otherwise)
          }
          if (maxExpansions > 0) {
            expansions++; // dirty hack for viz (not needed otherwise)
            this.type = "poly";
            this.update = (...args) => args;
            this.compileSelf = (r, args) =>
              `$.l=${args[0]}*0.3;$.r=${args[1] || args[0]}*0.3;`;
            // make mono if only one channel

            this.ins = Array(maxExpansions)
              .fill(0)
              .map((_, i) => {
                const clone = new this.constructor(
                  type,
                  [],
                  update,
                  compileSelf,
                  compileSetup
                );
                clone.ins = ins.map((input) => {
                  input = clone.parseInput(input);
                  if (input.type === "poly") {
                    return input.ins[i % input.ins.length];
                  }
                  return input;
                });
                return clone;
              });
          }
        }
      };
      Node.prototype.parseInput = function (input) {
        if (typeof input === "function") {
          input = input(this); // lambda feedback
        }
        if (Array.isArray(input)) {
          input = poly(...input);
        }
        return input;
      };
    </script>
    <!-- Node.run -->
    <script id="node-run">
      Node.prototype.run = function (visited = [], results = []) {
        if (visited.includes(this)) {
          return results[this.id] ?? 0;
        }
        // run children (depth first)
        const args = this.ins.map((input) => {
          if (input instanceof Node) {
            return input.run([...visited, this], results);
          }
          return input;
        });
        // pass children results to update
        const result = this.update(...args);
        results[this.id] = result;
        return result;
      };
      codeblock(document.currentScript, 8);
    </script>
    <script id="node-compile">
      Node.prototype.compile = function (memory) {
        let nodes = Array.from(topoSort(this));
        /* console.log("nodes", nodes); */
        $.n ??= [];
        const getRef = (input) =>
          typeof input !== "object" ? input : `r[${nodes.indexOf(input)}]`;
        let init = [
          `$.n ??= []; // init nodes array (if undefined)`,
          `const n = $.n; // only to save some chars`,
          `const r = new Float32Array(${nodes.length});`,
        ];
        let move = [];
        let create = [];
        let dsp = [`$.dsp = () => {`];
        for (let id in nodes) {
          const node = nodes[id];
          if (node.compileSetup) {
            const oldIndex = $.n.findIndex((n) => n === node);
            if (oldIndex === -1) {
              create.push(`${node.compileSetup(`n[${id}]`)} // ${node.type}`);
            } else if (oldIndex !== Number(id)) {
              move.push(`n[${id}] = n[${oldIndex}] // ${node.type}`);
            } else {
              // id hasn't changed -> no setup needed!
            }
          }
          const args = node.ins.map(getRef);
          const ref = getRef(node);
          let line;
          if (!node.compileSelf) {
            line = `${ref} = n[${id}].update(${args.join(",")})`;
          } else {
            line = node.compileSelf(ref, args, node, id);
          }
          line = `  ${line} // ${node.type}`;
          dsp.push(line);
        }
        const last = getRef(nodes[nodes.length - 1]);
        // lines.push(`return ${last}`);
        dsp.push(`}`);
        // TODO: move code can still lead to errors
        // it can happen that a variable is written before it is read
        // -> find way to sort move to not let that happen
        const code = [init, move, create, dsp].flat().join("\n");
        console.log("-------compiled--------");
        console.log(code);
        $.n = nodes;
        return code;
      };
    </script>
    <script id="node-play">
      const fadein = registerUgen("fadein", "FadeIn");
      const fadeout = registerUgen("fadeout", "FadeOut");
      const sine = registerUgen("sine", "SineOsc");
      const zaw = registerUgen("zaw", "ZawOsc");
      const saw = registerUgen("saw", "SawOsc");
      const lpf = registerUgen("lpf", "Lpf");
      const pulse = registerUgen("pulse", "PulseOsc");
      const dust = registerUgen("dust", "Dust");
      const impulse = registerUgen("impulse", "Impulse");
      const hold = registerUgen("hold", "Hold");
      const adsr = registerUgen("adsr", "ADSR");
      const delay = registerUgen("delay", "Delay");
      const fold = registerUgen("fold", "Fold");
      const lag = registerUgen("lag", "Lag");
      const slew = registerUgen("slew", "Slew");
      const seq = registerUgen("seq", "Sequence");
      const noise = registerRaw("noise", (r) => `${r} = Math.random() * 2 - 1`);

      const applyDistortion = (x, amount) => {
        amount = Math.min(Math.max(amount, 0), 1);
        amount -= 0.01;
        var k = (2 * amount) / (1 - amount);
        var y = ((1 + k) * x) / (1 + k * Math.abs(x));
        return y;
      };
      const distort = registerRaw(
        "distort",
        (r, a) => `${r} = applyDistortion(${a.join(",")})`
      );
      const hpf = register("hpf", (input, cutoff, resonance = 0) =>
        input.sub(input.lpf(cutoff, resonance))
      );

      const mix = register("mix", (input, channels = 1) => {
        if (![1, 2].includes(channels)) {
          channels = 2;
          console.warn(
            "mix only supports 1 or 2 channels atm.. falling back to 2"
          );
        }
        if (input.type !== "poly") {
          return input;
        }
        if (channels === 2) {
          const panned = input.ins.map((channel, i, ins) => {
            // we can do this at eval time: channels are fixed!
            const pos = (i / (ins.length - 1)) * 2 - 1;
            const deg = ((pos + 1) * Math.PI) / 4;
            const stereo = channel.mul([Math.cos(deg), Math.sin(deg)]);
            return stereo;
          });
          return add(...panned);
        }
        return add(...input.ins);
      });
      const ad = register("ad", (gate = 0, attack = 0.02, decay = 0.1) =>
        adsr(gate, attack, decay, 0, decay)
      );

      const range = registerRaw(
        "range",
        (r, [bip, a, b]) => `${r} = ((${bip} + 1) / 2) * (${b} - ${a}) + ${a}`
      );

      const unipolar = registerRaw(
        "unipolar",
        (r, [bip]) => `${r} = (${bip}+1)/2;`
      );
      const bipolar = registerRaw(
        "bipolar",
        (r, [uni]) => `${r} = ${uni}*2-1;`
      );

      const midi2freq = (midi) => Math.pow(2, (midi - 69) / 12) * 440;

      const _rangex = (sig, min, max) => {
        let logmin = Math.log(min);
        let range = Math.log(max) - logmin;
        const unipolar = (sig + 1) / 2;
        return Math.exp(unipolar * range + logmin);
      };
      const rangex = registerRaw(
        "rangex",
        (r, args) => `${r} = _rangex(${args.join(",")})`
      );

      const pan = register("pan", (input, pos) => {
        // (pos+1)/2 * PI/2 = (pos+1) * PI * 0.25
        return input;
        /* pos = add(pos, 1).mul(Math.PI, 0.25);
          return input.mul([Math.cos(pos), Math.sin(pos)]); */
      });

      const midinote = registerRaw(
        "midinote",
        (r, [note]) => `${r} = (2 ** ((${note} - 69) / 12) * 440)`
      );

      Node.prototype.apply = function (x) {
        return x(this);
      };

      Node.prototype.play = function () {
        // the last node must be poly to assign to $.l when compiled
        const out = this.type === "poly" ? this : n([this]);
        if (out.ins.length > 2) {
          // how about mix(2) in this case?
          console.warn("more than 2 channels! only using first 2");
        }
        out.viz();
        let code = out.compile();
        $.worklet.port.postMessage({ code });
      };
      Node.prototype.group = function (max = 1, fadeIn = 0, fadeOut = 0.1) {
        $.nodes ??= [];
        let len = $.nodes.length;
        // fade out / retire old nodes

        $.nodes = $.nodes.reduce((acc, node, i) => {
          // assumes nodes is poly node with at least 1 channel
          const in0 = node.ins[0];
          if (in0.type === "fadeout" && ctx.currentTime > node.deadline) {
            return acc; // omit already silent node
          }
          /* if (in0.type === "fadein" && in0.done) {
            node.ins = node.ins.map((input) => input.ins[0]);
          } */
          if (in0.type !== "fadeout" && len - i >= max) {
            if (!fadeOut) {
              return acc;
            }
            node = fadeout(node, fadeOut);
            node.deadline = ctx.currentTime + fadeOut + 1;
          }
          acc.push(node);
          return acc;
        }, []);

        // fade in new node
        let node = fadeIn ? this.fadein(fadeIn) : this;
        // make sure node is always poly (simplifies checks in reducer above)
        if (node.type !== "poly") {
          node = poly(node);
        }
        $.nodes.push(node);
        return add(...$.nodes);
      };
      Node.prototype.spawn = function (max, fadeIn, fadeOut) {
        return this.group(max, fadeIn, fadeOut).play();
      };
      Node.prototype.viz = function () {
        try {
          // console.log("viz", this, $.vizContainer);
          renderNode(this, $.vizContainer);
        } catch (err) {
          console.warn("non serializable node. probably because of feedback");
        }
        return this;
      };
    </script>
    <!-- Node.step -->
    <script>
      Node.prototype.step = function* (visited = [], results = []) {
        if (visited.includes(this)) {
          return results[this.id] ?? 0;
        }
        yield this;
        let args = [];
        let isLeaf = true;
        visited.push(this);
        for (let input of this.ins) {
          if (input instanceof Node) {
            isLeaf = false;
            yield* input.step(visited, results);
            const arg = input.run(visited, results);
            args.push(arg);
          } else {
            args.push(input);
          }
        }
        this.args = args;
        const result = this.update(...args);
        results[this.id] = result;
        if (!isLeaf) {
          yield this;
        }
        //results[this.id] = result;
      };
      //codeblock(document.currentScript, 8);
    </script>
    <script id="math-nodes">
      // register some nodes
      /* let add = registerFn("add", (a, b) => a + b);
      let sub = registerFn("sub", (a, b) => a - b);
      let mul = registerFn("mul", (a, b) => a * b);
      let div = registerFn("div", (a, b) => a / b);
      let mod = registerFn("mod", (a, b) => a % b);
      let n = registerFn("n", (a) => a); */

      let out = registerFn("out", (a) => a);
      let add = registerRaw("add", (r, a) => `${r} = ${a.join("+")}`);
      let sub = registerRaw("sub", (r, a) => `${r} = ${a.join("-")}`);
      let mul = registerRaw("mul", (r, a) => `${r} = ${a.join("*")}`);
      let div = registerRaw("div", (r, a) => `${r} = ${a.join("/")}`);
      let mod = registerRaw("mod", (r, a) => `${r} = ${a.join("%")}`);

      let n = registerRaw("n", (r, x) => `${r} = ${x}`);
    </script>
    <!-- topoSort -->
    <script>
      // sort nodes by dependencies (using generator function to be able to step through)
      function* topoSort(node, visited = new Set()) {
        if (!(node instanceof Node) || visited.has(node)) {
          return; // constant values or already visited nodes
        }
        visited.add(node);
        for (let input of node.ins) {
          yield* topoSort(input, visited);
        }
        yield node;
      }
    </script>
  </head>
  <body>
    <div class="logo">
      <img src="./img/kabelsalat_logo_scrot.png" />
    </div>
    <section>
      <h1>kabelsalat</h1>
      <p>graph based language for live coding on the web and beyond</p>
      <p>a project started on june 7, 2024 -> almost 1 year in the making</p>
      <p>paper by felix roos and raphael forment</p>
    </section>
    <section>
      <h2>kabelsalat is a..</h2>
      <ul>
        <li>1.graph based</li>
        <li>2.language</li>
        <li>3.for</li>
        <li>4.audio</li>
        <li>5.visual</li>
        <li>6.livecoding</li>
        <li>7.on the web</li>
        <li>8.and beyond</li>
      </ul>
    </section>
    <section>
      <h2>1.graph based</h2>
      <!-- ![graph](./img/pd_graph.png) -->
      <p><img src="./img/nc_graph2.png" alt="graph" /></p>
      <!-- ![graph](./img/ks_graph.png) -->
      <ul>
        <li>
          you&#39;ve seen patch based interfaces Pure Data, Max, cables.gl,
          noisecraft.. or modular synths
        </li>
        <li>modules + cables = graph</li>
        <li>each module has inputs and one or more outputs</li>
      </ul>
      <pre>Saw 55 -> Filter 0.5 -> AudioOut</pre>
    </section>
    <section>
      <h2>2.language</h2>
      <img
        src="./img/hydra_chaining.jpg"
        alt="hydra chaining"
        style="margin-top: -140px; width: 800px"
      />
    </section>
    <section>
      <h2>2.language</h2>
      <!-- <p>module = function, cable = data flow</p> -->
      <p>
        <img src="./img/lang_graphviz.svg" alt="lang graph" width="500px" />
      </p>
      <p>
        <img src="./img/lang_unnested.png" alt="lang unnested" width="500px" />
      </p>
      <p><img src="./img/lang_nested.png" alt="lang nested" width="500px" /></p>
      <p>
        <img src="./img/lang_imperative.png" alt="lang nested" width="500px" />
      </p>
      <!-- <pre>out(lpf(saw(55), 200))</pre>
      <pre>saw(55).lpf(200).out()</pre>
      <pre>
r[0] = saw(55)
r[1] = lpf(r[0], 200)
out(r[1])</pre
      > -->
    </section>
    <!-- <section>
      <h2>2.language</h2>
      <h3>Node class</h3>
      <script>
        codeblock(document.querySelector("#node-class"), 8);
      </script>
    </section>
    <section>
      <h2>2.language</h2>
      <h3>run method</h3>
      <script>
        codeblock(document.querySelector("#node-run"), 8);
      </script>
    </section> -->
    <!-- <section>
      <h2>2.language</h2>
      <script>
        codeblock(document.querySelector("#math-nodes"), 6);
      </script>
      <details>
        <summary>show implementation</summary>
        <script>
          codeblock(document.querySelector("#node-class"), 6);
        </script>
      </details>
    </section> -->
    <section>
      <h2>2.language</h2>
      <p>a simple chain:</p>
      <node-garden rows="3">return add(4, 2).mul(3).div(2).out()</node-garden>
    </section>
    <section>
      <h2>2.language</h2>
      <p>without method chaining:</p>
      <node-garden rows="3">return out(div(mul(add(4, 2), 3), 2))</node-garden>
      <!-- <p>we can mix and match method chaining and regular functions:</p>
      <pre>a.b(c) === b(a, c)</pre> -->
    </section>
    <section>
      <h2>2.language</h2>
      <p>we can reuse nodes using variables:</p>
      <node-garden rows="3">
        <!--
let a = add(1, 2)
return a.mul(3).add(a).out()
          -->
      </node-garden>
    </section>
    <section>
      <h2>2.language</h2>
      <p>tree walking:</p>
      <node-garden rows="3">
        <!--
return add(8,2).mul( add(3,5) )
.mul( add(2,3).mul(4) ).out()
-->
      </node-garden>
    </section>
    <section>
      <h2>2.language</h2>
      <p>multichannel expansion:</p>
      <node-garden rows="3">
        <!--
return add([2, 3], 1).mul(4)
      -->
      </node-garden>
    </section>
    <section>
      <h2>2.language</h2>
      <p>channel matching:</p>
      <node-garden rows="3">
        <!--
return add([2, 3], 1).mul([4, 5])
      -->
      </node-garden>
    </section>
    <section>
      <h2>2.language</h2>
      <p>feedback:</p>
      <node-garden rows="3">
        <!--
const node = add(1)
node.ins.push(node)
return node.out()
      -->
      </node-garden>
    </section>
    <section>
      <h2>2.language</h2>
      <p>feedback with lambdas:</p>
      <node-garden rows="3">
        <!--
return add(1, o=>o).out()
      -->
      </node-garden>
      <!-- <details>
        <summary>show implementation</summary>
        <script>
          codeblock(document.querySelector("#node-feedback"), 6);
        </script>
      </details> -->
    </section>
    <section>
      <h2>2.language</h2>
      <p>multichannel expansion + feedback:</p>
      <node-garden rows="3">
        <!--
return add([2, 3], o=>o)
      -->
      </node-garden>
    </section>
    <!-- <section>
      <h2>2. for</h2>
      <pre></pre>
    </section> -->
    <section>
      <h2>3. audio</h2>
      <p>dsp-repl, without kabelsalat:</p>
      <dsp-repl rows="6"
        ><!-- 
$.dsp = (t) => {
  $.l = $.r = sin(241*t*2*PI)/4
}
--></dsp-repl
      >
      <ul>
        <li>the $.dsp function runs for every sample = 48kHz</li>
        <li>$.l and $.r hold the speaker position between -1 and 1</li>
      </ul>
    </section>
    <section>
      <h2>3. audio</h2>
      <p>bytebeat example:</p>
      <dsp-repl rows="7"
        ><!-- 
$.dsp = () => {
  let t = $.t
  $.l = $.r = ((( // ryg 2011-10-10
((t*("36364689"[t>>13&7]&15))/12&128)+(((((t>>12)^(t>>12)-2)%11*t)/4|t>>13)&127)
) & 255) / 127.5 - 1)/4
}
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>with kabelsalat:</p>
      <dsp-repl rows="6"
        ><!--
let node = sine(241).div(4).viz()

$.dsp = (t) => {
  $.l = $.r = node.run()
}
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>play function:</p>
      <dsp-repl rows="6"
        ><!--
Node.prototype.play = function() {
  this.viz()
  $.dsp = (t) => ($.l = $.r = this.run())
}
sine(241).div(4).play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>play function:</p>
      <dsp-repl rows="6" next="1"
        ><!--
sine(241).div(4).play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>multichannel expansion:</p>
      <dsp-repl rows="6" next="1"
        ><!--
saw([120,121])
.lpf(sine(2).range(.2,.8))
.div(2)
.group(1, 1, 1)
.play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>spawn:</p>
      <dsp-repl rows="6" next="1"
        ><!--
$.m ??= 0
$.m = ($.m+5)%24
let f = midi2freq($.m+50)

saw(f).lpf(sine(2).range(.4,.5)).div(4)
.spawn(2, 0, 1)
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>stress test:</p>
      <dsp-repl rows="6" next="1"
        ><!--
sine(random()*800+100)
.group(1000, .1, .1)
.div(100)
.play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>distorted guitar:</p>
      <dsp-repl rows="12" next="1"
        ><!--
$.lfo ??= saw(.01)
$.lfo2 ??= sine(.5).range(.3,.7)
$.imp ??= impulse(4)

poly(55,110,220,330).mul(2).zaw()
.lpf( $.lfo2 )
.mix(2)
.mul( $.imp.ad(0,.1).lag(.05) )
.add(x=>x.delay($.lfo.range(.005,.02)).mul(.9))
.add(x=>x.delay(.3).mul(.7))
.fold()
.mul(.6)
.spawn(1,.1,.1)
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>stardust:</p>
      <dsp-repl rows="12" next="1"
        ><!--
// stardust
// by pulu : https://pulusound.fi
let mel = n(sine(0.1).rangex(1, 5)).dust().apply(g => 
  g.ad(0.001,sine(11.23).rangex(0.07, 0.2)).mul(
    g.seq(52,57,60,59,45,52,59,45,57).add(g.seq(12,12,24,12,12,12)).midinote()
      .mul(g.ad(0.001,0.03).bipolar().rangex(1,noise().hold(g).rangex(0.5,2)))
      .sine()
      .mul(noise().hold(g).lag(0.001).range(0.2,1))
      .pan(noise().hold(g).lag(0.003).mul(0.8))
  )
)
  .add(x => x.delay(sine(0.121).rangex(0.333, 0.347)).mul(sine(0.54).rangex(0.3, 0.7)))
  .add(x => x.delay(sine(0.131).rangex(0.543, 0.557)).mul(sine(0.64).rangex(0.3, 0.7)))
  .mul(1.05);
let wind = noise()
  .mul(dust(18).ad(0.003,0.05).bipolar().rangex(0.6,1))
  .add(noise().hold(dust(500)))
  .mul(n(0.7).apply(r => noise().hold(impulse(r)).slew(r).rangex(0.4,1)))
  .distort(0.5)
  .lpf(n(0.2).apply(r => noise().hold(impulse(r)).slew(r).rangex(0.5,0.9)),0.2)
  .hpf(n(0.33).apply(r => noise().hold(impulse(r)).slew(r).rangex(0.3,0.4)))
  .pan(sine(0.12).mul(0.7))
  .add(x => x.delay(0.65).mul(0.72))
  .mul(0.2);
let drone = add(...[0,7,10,12].map((x,i) =>
  n(x+45).midinote().sine()
    .mul(n(x/25).sine(0, i/2*Math.PI).unipolar())
    .pan(sine(1, 0, i/2*Math.PI).mul(0.6))
))
  .mul(0.8);
add(mel, wind, drone)
.spawn(1,4,4)
//.play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p><img src="./img/nathan_ho_kick.png" alt="nathan ho kick" /></p>
      <pre>
sine(60)
.perc(.001, .3)
.mul(.4)
.pan(sine(.4))
.out()</pre
      >
      <dsp-repl rows="6"
        ><!-- 
sine(61)
.range(200,400)
.sine()
.div(4)
.play()
--></dsp-repl
      >

      <dsp-repl rows="8"
        ><!-- 
$.m ??= 0
$.m = ($.m+5)%24
let f = midi2freq($.m+60)
sine(f)
.div(4)
.mul(sine(2).range(.5,1))
.group(3, .01, .5).play()
-->
      </dsp-repl>
    </section>

    <section>
      <dsp-repl rows="8"
        ><!-- 
$.mem ??= new Float32Array(8)
let node = add(1,o=>o).mul(121/$.SR)
.mod(1).sub(0.5)
.compile($.mem)
$.dsp = (t) => {
  $.l = $.r = node.run()
}
-->
      </dsp-repl>
    </section>
    <section>
      <ul>
        <li>
          <p>
            <a href="https://garten.salat.dev/kabelsalat/graph-language.html"
              >a graph language</a
            >
          </p>
        </li>
        <li><p>show Node data structure</p></li>
        <li>talk about mondo?</li>
      </ul>
    </section>
    <script>
      const slides = Array.from(document.querySelectorAll("section"));
      let slideIndex = Number(window.location.hash.slice(1)) || 0;
      let setSlideIndex = (index) => {
        slideIndex = index % slides.length;
        console.log("slideIndex", slideIndex);
        slides.forEach((slide, i) => {
          //slide.style.display = "none";
          if (i < slideIndex) {
            /* slide.style.transform = "translate(-100vw)"; */
            slide.style.opacity = "0";
            slide.style.pointerEvents = "none";
          } else if (i === slideIndex) {
            /* slide.style.transform = "translate(0px,0px)"; */
            slide.style.opacity = "1";
            //slide.style.display = "flex";
            slide.style.pointerEvents = "inherit";
          } else if (i > slideIndex) {
            /* slide.style.transform = "translate(100vw)"; */
            slide.style.opacity = "0";
            slide.style.pointerEvents = "none";
          }
          // slide.style.display = "none";
        });
        const slide = slides[slideIndex];
        // slide.style.display = "flex";
        window.location.hash = slideIndex;
      };
      setSlideIndex(slideIndex);
      let nextSlide = () => setSlideIndex((slideIndex + 1) % slides.length);
      let prevSlide = () =>
        setSlideIndex((slideIndex - 1 + slides.length) % slides.length);
      window.nextSlide = nextSlide;
      window.prevSlide = prevSlide;
      document.onkeydown = (e) => {
        if (e.ctrlKey) {
          if (e.key === "ArrowLeft") {
            prevSlide();
          } else if (e.key === "ArrowRight") {
            nextSlide();
          }
        }
      };
    </script>
  </body>
</html>
