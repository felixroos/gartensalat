<!DOCTYPE html>
<html>
  <head>
    <title>iclc 2025: kabelsalat</title>
    <link
      rel="icon"
      type="image/png"
      href="https://kabel.salat.dev/favicon.png"
    />
    <style>
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        overflow: hidden;
      }
      button {
        background: #222;
        border: 2px solid #555;
        color: white;
        font-size: 1em;
        padding: 2px 4px 4px 4px;
        cursor: pointer;
        &:hover {
          background: #333;
        }
        &:active {
          background: #666;
        }
      }
      node-garden,
      dsp-repl,
      details {
        width: 100%;
        max-width: 800px;
      }
      body {
        background-color: #1d1918;
        margin: auto;
        font-family: serif;
        font-size: 1.2em;
        color: #edd;
        padding: 20px 8px;
        padding: 0;
      }
      section {
        * {
          flex-shrink: 0;
        }
        position: absolute;
        top: 0;
        left: 0;
        transition: all 0.5s ease-in-out;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 80px 20px;
        width: 100%;
        font-size: 1.5em;
        img {
          max-width: 100%;
        }
        padding-bottom: 500px;
        opacity: 0;
        width: 100%;
        height: 100%;
        /* padding-bottom: 500px; */
        overflow: auto;
        h1,
        h2,
        h3 {
          position: sticky;
          top: 0px;
          padding: 8px;
          background: #1d1918;
          margin-bottom: 20px;
        }
      }
      @font-face {
        font-family: "FontWithASyntaxHighlighter";
        src: url("./FontWithASyntaxHighlighter-Regular.woff2") format("woff2");
      }
      a {
        color: cyan;
        font-size: 1em;
      }
      textarea,
      pre {
        box-sizing: border-box;
        font-family: "FontWithASyntaxHighlighter", monospace;
        padding: 8px;
        font-size: 0.85em;
        border: 0;
        outline: none;
        overflow: auto;
        background-color: #44444490;
        color: white;
        width: 100%;
        margin: 8px 0;
        box-sizing: border-box;
        max-width: 800px;
      }
      #lines {
        height: 200px;
      }
      .logo {
        display: flex;
        top: 0;
        position: absolute;
        align-items: flex-end;
        img {
          height: 50px;
        }
      }
    </style>
    <!-- codeblock -->
    <script>
      // render codeblock from script tag
      let codeblock = (scriptElement, indent = 0) => {
        const script = document.currentScript;
        const pre = document.createElement("pre");
        pre.textContent = getCode(scriptElement, indent);
        script.after(pre);
      };
      function getCode(scriptElement, indent = 0) {
        return scriptElement.innerText
          .split("\n")
          .map((line) => line.slice(indent))
          .filter((x) => x && !x.startsWith("codeblock("))
          .join("\n");
      }
    </script>
    <!-- node-garden -->
    <script>
      class NodeGarden extends HTMLElement {
        static observedAttributes = ["code", "rows"];
        init() {
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "")
              .replace("<!--", "")
              .replace("-->", "")
              .trim() ||
            "";
          this.innerHTML = "";
          const rows = this.getAttribute("rows") ?? 6;

          this.insertAdjacentHTML(
            "beforeend",
            `
      <div style="padding:0;width:100%">
        <div class="viz" style="display:flex;justify-content:center;padding:10px;height:300px"></div>
        <textarea id="code" spellcheck="false" rows="${rows}" style="margin:0;border-bottom:2px solid #222;width:100%;font-size:.8em"></textarea>
        <div style="position:relative">
          <pre class="result">
          </pre>
          <div style="display:flex;position:absolute;right:0;top:0">
            <button style="margin-right:8px" class="run">run</button>
            <button style="margin-right:8px" class="reset">reset</button>
            <button class="step">step</button>
            <button class="contract">-</button>
            <button class="expand">+</button>
          </div>
        </div>
        <details>
          <summary>show steps</summary>
          <pre class="steps"></pre>
        </details>

      </div>`
          );
          // repl logic
          const input = this.querySelector("textarea");
          this.result = this.querySelector(".result");
          this.steps = this.querySelector(".steps");
          this.vizContainer = this.querySelector(".viz");
          this.runButton = this.querySelector(".run");
          this.stepButton = this.querySelector(".step");
          this.resetButton = this.querySelector(".reset");
          this.contractButton = this.querySelector(".contract");
          this.expandButton = this.querySelector(".expand");
          input.value = code;
          this.input = input;
          this.reset();

          this.stepButton.addEventListener("click", () => this.step());
          this.runButton.addEventListener("click", () => this.update());
          this.resetButton.addEventListener("click", () => this.reset());
          this.contractButton.addEventListener("click", () => this.contract());
          this.expandButton.addEventListener("click", () => this.expand());

          input.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              this.update();
            } else if ((e.ctrlKey || e.altKey) && e.key === ".") {
              e.preventDefault();
              this.stop();
            }
          });
        }
        setCode(code) {
          this.code = code;
          this.input.value = code;
          this.update();
        }
        reset() {
          this.results = [];
          this.update();
          this.results = []; // maybe this is not needed..
          this.currentNode = null;
          this.visited = [];
          delete this.stepper;
          this.steps.innerText = "// click step to start walking";
          // this.render();
        }
        render() {
          renderNode(this.node, this.vizContainer);
        }
        nodeColor(node) {
          const cid = this.currentNode?.id;
          if (node.id === cid) {
            return "magenta";
          }
          if (this.results[node.id] !== undefined) {
            return "cyan";
          }
          if (this.visited.find((v) => v.id === node.id)) {
            return "yellow";
          }
          return "white";
        }
        renderStepped() {
          // renderNode(this.node, this.vizContainer);
          const cid = this.currentNode?.id;
          renderNode(
            this.node,
            this.vizContainer,
            (node) => {
              node.color = this.nodeColor(node);

              //node.label = `${n.id}: ${n.type} ${n.ins
              const n = this.nodes[node.id];
              /* node.label = `${n.type} ${n.ins
                .map((input, i) =>
                  input instanceof Node
                    ? (cid < n.id ? "_" : n.args?.[i]) ?? "_"
                    : input
                )
                .join(" ")}`; */

              return node;
            },
            (edge) => {
              const source = this.nodes[edge.source];
              const target = this.nodes[edge.target];
              const argIndex = target.ins.findIndex(
                (input) => input.id === edge.source
              );
              const sourceColor = this.nodeColor(source);
              const targetColor = this.nodeColor(target);

              if (
                edge.target === cid /* ||
                (edge.source === cid && this.results[edge.source] !== undefined) */
              ) {
                edge.color = "magenta";
                //} else if ([targetColor, sourceColor].includes("cyan")) {
                //} else if (this.results[edge.source] !== undefined) {
                //} else if (targetColor === "cyan") {
              } else if (sourceColor === "cyan") {
                edge.color = "cyan";
              } else if (this.visited.find((v) => v.id === edge.target)) {
                edge.color = "yellow";
              }

              const hasResult = this.results[edge.source] !== undefined;
              if (!hasResult && ["magenta"].includes(edge.color)) {
                edge.label = "?";
              } else if (["yellow"].includes(edge.color)) {
                edge.label = "?";
              } else if (edge.target <= cid || cid === undefined) {
                edge.label = target.args?.[argIndex] ?? "";
              } else {
                edge.label = this.results[edge.source] ?? "";
              }
              /* edge.label =
                target.args?.[argIndex] ?? this.results[edge.source] ?? ""; */
              return edge;
            }
          );
        }
        evaluate() {
          const fn = new Function("self", this.input.value);
          this.node = fn(this);
          this.nodes = Array.from(topoSort(this.node));
          this.nodes.forEach((node, i) => {
            node.id = i;
          });
        }
        async update() {
          // this.results = []; // clear state
          expansions = 0;
          this.evaluate();
          this.render();
          this.result.innerText = `= ${this.node.run([], this.results)}`;
        }
        step() {
          if (!this.stepper) {
            this.visited = [];
            //this.results = []; // uncomment to disable feedback
            /* this.evaluate(); */
            this.stepper = this.node.step(this.visited, this.results);
            this.result.innerText = "= ?";
          }
          const next = this.stepper.next();
          this.currentNode = next.value;
          const cid = this.currentNode?.id;

          this.renderStepped();
          const calculations =
            this.results
              .map((result, i) => {
                const n = this.nodes[i];
                if (!this.visited.includes(n) || n.id >= cid) {
                  return "";
                }
                //const output = result
                const output = cid < i ? "?" : result ?? "??";
                return `r[${i}] = ${n.type}(${n.ins
                  .map((input, i) =>
                    input instanceof Node ? `r[${input.id}]` : input
                  )
                  .join(", ")}) = ${output}`;
              })
              .filter(Boolean)
              .join("\n") || `// searching computable nodes`;
          this.steps.innerText = calculations;
          if (!this.currentNode) {
            this.result.innerText = `= ${
              this.results[this.results.length - 1]
            }`;
            delete this.stepper;
            return;
          }
        }
        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          if (name === "code") {
            this.setCode(newValue);
          }
        }
        contract() {
          this.renderExpansion(expansion - 1);
        }
        expand() {
          this.renderExpansion(expansion + 1);
        }
        renderExpansion(_expansion = 0) {
          expansion = Math.max(_expansion, 0);
          expansion = Math.min(expansion, nextExpansion);
          expansions = 0;
          this.evaluate();
          let nodes = Array.from(topoSort(this.node));
          renderNode(this.node, this.vizContainer, (gvnode) => {
            const node = nodes[gvnode.id];
            if (node.type === "poly") {
              gvnode.color = "orchid";
            } else if (node.ins.find((input) => input?.type === "poly")) {
              gvnode.color = "cyan";
            }
            return gvnode;
          });

          if (!nodes.slice(0, -1).find((node) => node.type === "poly")) {
            nextExpansion = expansion; // cannot step more
            console.log("done expanding");
          } else {
            nextExpansion = expansion + 1; // at least one more...
          }
        }
      }
      customElements.define("node-garden", NodeGarden);
    </script>
    <!-- graphviz -->
    <script>
      function gvjson2dot(json) {
        const { nodes, edges } = json;
        let renderProps = (props) =>
          `[${Object.entries(props)
            .map(([key, value]) => `${key}="${value}"`)
            .join(",")}]`;
        return `digraph {
            bgcolor="transparent";
            rankdir="LR";
            node [penwidth=4];
            edge [penwidth=2];
            ${nodes
              .map((node) => `  "${node.id}" ${renderProps(node)}`)
              .join("\n")}
            ${edges
              .map(
                (edge) =>
                  `  ${edge.source} -> ${edge.target} ${renderProps(edge)}`
              )
              .join("\n")}
            }`;
      }
      function node2gvjson(graph, editNode, editEdge) {
        let dfs = (node, fn, visited = []) => {
          if (typeof node !== "object") {
            return node;
          }
          visited.push(node);
          node.ins = node.ins.map((input) => {
            if (visited.includes(input)) {
              return input;
            }
            return dfs(input, fn, visited);
          });
          node = fn(node, visited);
          return node;
        };
        const nodes = [],
          edges = [];
        let style = {
          color: "white",
          fontcolor: "white",
          fontsize: "10",
          fontname: "monospace",
        };
        dfs(graph, (node) => {
          node.id = nodes.length;
          let gvnode = {
            id: node.id,
            label: `${node.type} ${node.ins
              .map((input) => (typeof input === "object" ? "_" : input))
              .join(" ")}`,
            ordering: "in",
            width: "0.5",
            height: "0.4",
            ...style,
          };
          if (editNode) {
            gvnode = editNode(gvnode);
          }
          nodes.push(gvnode);
          for (let i in node.ins) {
            if (typeof node.ins[i] !== "object") {
              continue;
            }
            if (node.ins[i].id === undefined) {
              console.log("undefined source id", node.ins[i]);
            }
            let gvedge = {
              label: "",
              id: edges.length,
              source: node.ins[i].id ?? "whuuuat",
              target: node.id,
              directed: "true",
              ...style,
            };
            if (editEdge) {
              gvedge = editEdge(gvedge);
            }
            edges.push(gvedge);
          }
          return node;
        });
        return { nodes, edges };
      }
      function node2dot(node, editNode, editEdge) {
        const flat = node2gvjson(node, editNode, editEdge);
        const dot = gvjson2dot(flat);
        return dot;
      }
      async function renderDot(dot, container) {
        // this breaks my rule of self-contained html :/
        // but graphviz is just so good..
        // i don't want to segway into graph layouting rn...
        // download the file here: https://unpkg.com/@hpcc-js/wasm@2.18.0/dist/graphviz.js
        // sorry if you're living in 2051 and npm has collapsed already..
        const { Graphviz } = await import("./graphviz.js");
        const graphvizLoaded = Graphviz.load();
        const graphviz = await graphvizLoaded;
        const svg = await graphviz.layout(dot, "svg", "dot", {});
        const base64 = btoa(unescape(encodeURIComponent(svg)));
        const dataUrl = `data:image/svg+xml;base64,${base64}`;
        const img = document.createElement("img");
        img.src = dataUrl;
        img.style.maxHeight = "200px";
        img.style.width = "600px";
        container.innerText = "";
        container.appendChild(img);
      }
      function renderNode(node, container, editNode, editEdge) {
        const dot = node2dot(node, editNode, editEdge);
        return renderDot(dot, container);
      }
    </script>
    <!-- Node -->
    <script id="node-class">
      let Node = class {
        constructor(type, ins, update) {
          this.type = type;
          this.ins = ins;
          this.update = update;
        }
      };
    </script>

    <template class="dsp-worklet">
      <script>
        class DspProcessor extends AudioWorkletProcessor {
          dsp = () => {};
          l = 0;
          r = 0;
          SR = sampleRate;
          ISR = 1 / sampleRate;
          constructor() {
            super();
            this.t = 0;
            this.active = true;
            this.framebuffer = new Float32Array(Math.floor(sampleRate / 30));
            this.msg = {
              framebuffer: this.framebuffer,
            };
            globalThis.$ = this;
            this.port.onmessage = (e) => {
              const msg = e.data;
              if (msg && msg.code) {
                //new Function("$", msg.code)(this);
                new Function(msg.code)();
              } else if (msg === "stop") {
                this.active = false;
              }
            };
          }
          process(inputs, outputs, parameters) {
            const output = outputs[0];
            for (let i = 0; i < output[0].length; i++) {
              this.dsp(this.t / sampleRate);
              output[0][i] = this.l;
              output[1][i] = this.r;
              this.t++;
              this.framebuffer[this.t % this.framebuffer.length] = this.l;
              if (this.t % this.framebuffer.length === 0 && this.t > 0) {
                this.port.postMessage(this.msg);
              }
            }
            return this.active;
          }
        }
      </script>
    </template>
    <!-- dsp-repl -->
    <script>
      const ctx = new AudioContext();
      // init audio context
      document.addEventListener("click", function firstClick() {
        ctx.resume(); // autoply policy
        document.removeEventListener("click", firstClick);
      });

      const _lerp = (v, min, max) => v * (max - min) + min;
      const invLerp = (v, min, max) => (v - min) / (max - min);
      const remap = (v, vmin, vmax, omin, omax) =>
        _lerp(invLerp(v, vmin, vmax), omin, omax);

      class DSPRepl extends HTMLElement {
        static observedAttributes = ["code", "rows"];
        worklet;
        init() {
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "").replace("<!--", "").replace("-->", "").trim();

          const rows = this.getAttribute("rows") ?? 4;
          if (!code) {
            return;
          }
          this.innerHTML = "";
          this.insertAdjacentHTML(
            "beforeend",
            `<div style="border:2px solid #222;padding:0;">
            
            <textarea id="code" spellcheck="false" rows="${rows}"></textarea>
            <div style="user-select:none;cursor:pointer">
            <button class="play">run</button> <button class="stop">stop</button>
            </div>
            <canvas width="400" height="80"></canvas>
            <div class="viz" style="display:none;justify-content:center;padding:10px;height:300px"></div>
            </div>
              `
          );
          // draw logic
          this.vizContainer = this.querySelector(".viz");
          this.canvas = this.querySelector("canvas");
          this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;
          this.canvas.height =
            this.canvas.clientHeight * window.devicePixelRatio;
          this.drawContext = this.canvas.getContext("2d");
          this.drawSilence(this.drawContext);

          // repl logic
          const input = this.querySelector("textarea");
          input.value = code;
          input.style = "margin:0;border-bottom:2px solid #222";
          this.input = input;

          this.querySelector(".play").onclick = () => this.update(input.value);
          this.querySelector(".stop").onclick = () => this.stop();
          input.addEventListener("keydown", async (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              const hash = btoa(input.value);
              let urlCode = window.location.hash.slice(1);
              this.update(input.value);
            }
            if ((e.ctrlKey || e.altKey) && e.code === "Period") {
              e.preventDefault();
              this.stop();
            }
          });
        }
        async initWorklet() {
          if (this.worklet) {
            return;
          }
          await ctx.resume();
          this.worklet = await this.runWorklet(ctx, this.input.value);
          this.worklet.port.onmessage = (e) => {
            if (e.data.framebuffer) {
              requestAnimationFrame(() => this.drawBuffer(e.data.framebuffer));
            } else if (e.data.viz) {
              const node = JSON.parse(e.data.viz);
              renderNode(node, this.vizContainer);
              this.vizContainer.style.display = "block";
            }
          };
        }

        async update(code) {
          await this.initWorklet();
          this.worklet.port.postMessage({ code });
        }
        stop() {
          this.worklet?.disconnect();
          this.worklet?.port.postMessage("stop");
          this.worklet = undefined;
        }

        async runWorklet(ac) {
          const name = `worklet-${Date.now()}`;
          const math = Object.getOwnPropertyNames(Math).join(",");
          let prelude = `const {${math}} = Math;\nObject.assign(globalThis,{${math}})\n`;
          // add dsp scripts
          document
            .querySelector("template.dsp-prelude")
            .content.querySelectorAll("script")
            .forEach((script) => {
              prelude += script.textContent;
            });

          let workletCode = document
            .querySelector("template.dsp-worklet")
            .content.querySelector("script").textContent;

          workletCode = `${prelude}\n${workletCode}\nregisterProcessor('${name}', DspProcessor);`;

          await ac.resume();
          const dataURL = `data:text/javascript;base64,${btoa(workletCode)}`;
          await ac.audioWorklet.addModule(dataURL);
          const node = new AudioWorkletNode(ac, name, {
            outputChannelCount: [2],
          });
          node.connect(ac.destination);
          return node;
        }

        drawBuffer(samples) {
          const ctx = this.drawContext;
          const canvas = ctx.canvas;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.lineWidth = 2;
          ctx.strokeStyle = "white";
          let x0 = 1;
          let x1 = samples.length;
          let y0 = -1;
          let y1 = 1;
          let px0 = 0;
          let px1 = ctx.canvas.width;
          let py0 = ctx.canvas.height - ctx.lineWidth;
          let py1 = ctx.lineWidth;
          ctx.beginPath();
          for (let px = 0; px < ctx.canvas.width; px++) {
            const x = remap(px, px0, px1, x0, x1);
            const y = samples[Math.floor(x)];
            const py = remap(y, y0, y1, py0, py1);
            px === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
          }
          ctx.stroke();
        }

        drawSilence(ctx, color = "white", lineWidth = 2) {
          const canvas = ctx.canvas;
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height / 2);
          ctx.lineTo(canvas.width, canvas.height / 2);
          ctx.stroke();
        }

        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          this.init();
        }
      }
      customElements.define("dsp-repl", DSPRepl);
    </script>
    <template class="dsp-prelude">
      <!-- Node -->
      <script>
        // https://garten.salat.dev/kabelsalat/graph-computation.html
        class DspNode {
          constructor(type, ins, update, compileSelf) {
            this.type = type;
            update && (this.update = update);
            compileSelf && (this.compileSelf = compileSelf);

            // multichannel expansion
            let maxExpansions = 0;
            this.ins = ins.map((input) => {
              input = this.parseInput(input);
              if (input.type === "poly") {
                maxExpansions = Math.max(maxExpansions, input.ins.length);
              }
              return input;
            });
            if (maxExpansions > 0) {
              this.type = "poly";
              this.update = (...args) => args;
              this.compileSelf = (args) =>
                `${args.join("+")};\n$.l=${args[0]};$.r=${args[1] || args[0]};`;
              // make mono if only one channel

              this.ins = Array(maxExpansions)
                .fill(0)
                .map((_, i) => {
                  const clone = new this.constructor(
                    type,
                    [],
                    update,
                    compileSelf
                  );
                  clone.ins = ins.map((input) => {
                    input = clone.parseInput(input);
                    if (input.type === "poly") {
                      return input.ins[i % input.ins.length];
                    }
                    return input;
                  });
                  return clone;
                });
            }
          }
          run() {
            const args = this.ins.map((input) => {
              if (input instanceof Node) {
                return input.run();
              }
              return input;
            });
            return this.update(...args);
          }
        }

        globalThis.Node = DspNode;
        Node.prototype.parseInput = function (input) {
          if (typeof input === "function") {
            input = input(this); // lambda feedback
          }
          // multichannel expansion
          if (Array.isArray(input)) {
            input = poly(...input);
          }
          return input;
        };
        // compile should also expand..
        // saw([120,240]).compile().play() // <-- should remain stereo...
        // = poly(saw(120).compile(), saw(240).compile())
        Node.prototype.compile = function (memory) {
          let nodes = Array.from(topoSort(this));
          // console.log(memory.join("\n"));
          let r = memory ? memory : Array(nodes.length).fill(0);
          const getRef = (input) =>
            typeof input !== "object" ? input : `r[${nodes.indexOf(input)}]`;
          let lines = [];
          for (let id in nodes) {
            const node = nodes[id];
            const args = node.ins.map(getRef);
            const ref = getRef(node);
            if (!node.compileSelf) {
              lines.push(`${ref} = n[${id}].update(${args.join(",")})`);
            } else {
              lines.push(`${ref} = ${node.compileSelf(args, node, id)}`);
            }
            lines[lines.length - 1] += ` // ${node.type}`;
          }
          const last = getRef(nodes[nodes.length - 1]);
          lines.push(`return ${last}`);
          const code = lines.join("\n");
          console.log("-------compiled--------");
          console.log(code);
          const update = new Function("n", "r", code);
          const node = new Node("compiled", [], () => update(nodes, r));
          return node;
        };
        Node.prototype.viz = function () {
          $.port.postMessage({ viz: JSON.stringify(this) });
          return this;
        };
        let registerNode = (type, getNode) => {
          Node.prototype[type] = function (...args) {
            return getNode(this, ...args);
          };
          return getNode;
        };
        globalThis.registerFn = (type, update) =>
          registerNode(type, (...args) => new Node(type, args, update));

        globalThis.registerClass = (type, NodeClass) =>
          registerNode(type, (...args) => new NodeClass(type, args));

        globalThis.registerRaw = (type, compileSelf) =>
          registerNode(type, (...args) => {
            const argNames = Array.from(
              { length: args.length },
              (_, i) => `a${i}`
            );
            const body = `return ${compileSelf(argNames)}`;
            const update = new Function(...argNames, body);
            return new Node(type, args, update, compileSelf);
          });
        globalThis.poly = registerFn("poly", (...args) => args);
      </script>
      <!-- topoSort -->
      <script>
        // https://garten.salat.dev/kabelsalat/graph-compilation.html
        // sort nodes by dependencies (using generator function to be able to step through)
        function* topoSort(node, visited = new Set()) {
          if (!(node instanceof Node) || visited.has(node)) {
            return; // constant values or already visited nodes
          }
          visited.add(node);
          for (let input of node.ins) {
            yield* topoSort(input, visited);
          }
          yield node;
        }
      </script>
      <script id="play-method">
        Node.prototype.play = function () {
          // the last node must be poly to assign to $.l when compiled
          const out = this.type === "poly" ? this : n([this]);
          out.viz();
          let compiled = out.compile();
          $.dsp = () => compiled.run();
          return compiled;
        };
      </script>
      <script id="collect-method">
        Node.prototype.collect = function (max = 1) {
          $.nodes ??= [];
          $.nodes.push(this);
          $.nodes = $.nodes.slice(-max);
          return add(...$.nodes);
        };
      </script>
      <script id="group-method">
        Node.prototype.group = function (max = 1, fadeIn = 0, fadeOut = 0.1) {
          $.nodes ??= [];
          let len = $.nodes.length;
          // fade out / retire old nodes

          $.nodes = $.nodes.reduce((acc, node, i) => {
            // assumes nodes is poly node with at least 1 channel
            const in0 = node.ins[0];
            //console.log("in0", in0);
            if (in0.type === "fadeout" && in0.done) {
              return acc; // omit already silent node
            }
            if (in0.type === "fadein" && in0.done) {
              node.ins = node.ins.map((input) => input.ins[0]);
            }
            if (in0.type !== "fadeout" && len - i >= max) {
              node = fadeout(node, fadeOut * $.SR);
            }
            acc.push(node);
            return acc;
          }, []);

          // fade in new node
          let node = fadeIn ? this.fadein(fadeIn * $.SR) : this;
          // make sure node is always poly (simplifies checks in reducer above)
          if (node.type !== "poly") {
            node = poly(node);
          }
          $.nodes.push(node);
          return add(...$.nodes);
        };
      </script>
      <script id="fade">
        // maybe these could be combined into a single Node
        class FadeIn extends Node {
          start = $.t;
          done = false;
          update(input, fadeTime = 1000) {
            const progress = ($.t - this.start) / fadeTime;
            if (progress >= 1) {
              this.done = true;
              return input;
            }
            const gain = Math.min(1, progress);
            return input * gain;
          }
        }
        let fadein = registerClass("fadein", FadeIn);
        class FadeOut extends Node {
          start = $.t;
          done = false;
          update(input, fadeTime = 1000) {
            this.init = true;
            const progress = ($.t - this.start) / fadeTime;
            if (progress >= 1) {
              this.done = true;
              return 0;
            }
            const gain = 1 - Math.min(1, progress);
            return input * gain;
          }
        }
        let fadeout = registerClass("fadeout", FadeOut);
      </script>
      <script>
        // https://garten.salat.dev/audio-dsp/oscillators.html
        class SineOsc extends Node {
          phase = 0;
          update(freq) {
            const value = Math.sin(this.phase * 2 * Math.PI);
            this.phase = (this.phase + freq / sampleRate) % 1;
            return value;
          }
        }
        globalThis.SineOsc = SineOsc;
        globalThis.sine = registerClass("sine", SineOsc);
        globalThis.lpf = registerClass(
          "lpf",
          class extends Node {
            s0 = 0;
            s1 = 0;
            update(s, cutoff, resonance = 0) {
              // Out of bound values can produce NaNs
              cutoff = Math.min(cutoff, 1);
              resonance = Math.max(resonance, 0);
              var c = Math.pow(0.5, (1 - cutoff) / 0.125);
              var r = Math.pow(0.5, (resonance + 0.125) / 0.125);
              var mrc = 1 - r * c;
              var v0 = this.s0;
              var v1 = this.s1;
              // Apply the filter to the sample
              v0 = mrc * v0 - c * v1 + c * s;
              v1 = mrc * v1 + c * v0;
              s = v1;
              this.s0 = v0;
              this.s1 = v1;
              return s;
            }
          }
        );
        globalThis.saw = registerClass(
          "saw",
          class extends Node {
            phase = 0;
            update(freq) {
              this.phase += $.ISR * freq;
              return (this.phase % 1) * 2 - 1;
            }
          }
        );
        globalThis.midi2freq = (midi) => Math.pow(2, (midi - 69) / 12) * 440;
        globalThis.range = registerRaw(
          "range",
          ([bip, a, b]) => `((${bip} + 1) / 2) * (${b} - ${a}) + ${a}`
        );

        globalThis.add = registerRaw("add", (args) => args.join("+"));
        globalThis.sub = registerRaw("sub", (args) => args.join("-"));
        globalThis.mul = registerRaw("mul", (args) => args.join("*"));
        globalThis.div = registerRaw("div", (args) => args.join("/"));
        globalThis.mod = registerRaw("mod", (args) => args.join("%"));
        globalThis.n = registerRaw("n", (x) => x);

        // sine(240).raw(([n]) => `${n}/16`)
        /* let raw = registerNode("raw", (...args) => {
          const compileSelf = args[args.length - 1];
          return new Node("raw", args.slice(0, -1), null, compileSelf);
        }); */
        /* let raw = (type, compileSelf) =>
          registerNode((...args) => new Node(type, args, null, compileSelf));
        let raw = registerRaw('raw', ()) */
        // sine(100).raw((arg) => `${arg}/2`)
        Object.assign(globalThis, {
          Node,
        });
      </script>
    </template>
    <script>
      let registerWith = (type, getNode) => {
        // register method for chaining
        Node.prototype[type] = function (...args) {
          return getNode(type, [this, ...args]);
        };
        // return function for unchained calls
        return (...args) => getNode(type, args);
      };
      let registerFn = (type, update) =>
        registerWith(type, (type, args) => new Node(type, args, update));
    </script>
    <script id="node-feedback">
      Node = class {
        constructor(type, ins, update) {
          this.type = type;
          this.ins = this.ins.map((input) => this.parseInput(input));
          this.update = update;
        }
      };
      Node.prototype.parseInput = function (input) {
        if (typeof input === "function") {
          return input(this);
        }
        return input;
      };
    </script>
    <script id="node-expansion">
      let poly = registerFn("poly", (...args) => args);

      // these variables are for the stepwise viz (very dirty hack)
      let expansions = 0;
      let expansion = -1;
      let nextExpansion = 1;

      Node = class {
        constructor(type, ins, update) {
          this.type = type;
          this.update = update;
          let maxExpansions = 0;
          this.ins = ins.map((input) => {
            input = this.parseInput(input);
            if (input.type === "poly") {
              maxExpansions = Math.max(maxExpansions, input.ins.length);
            }
            return input;
          });
          if (expansion !== -1 && expansions >= expansion) {
            return; // dirty hack for viz (not needed otherwise)
          }
          if (maxExpansions > 0) {
            expansions++; // dirty hack for viz (not needed otherwise)
            // multichannel expansion
            this.type = "poly";
            this.update = (...args) => args;
            this.ins = Array(maxExpansions)
              .fill(0)
              .map((_, i) => {
                const clone = new this.constructor(type, [], update);
                clone.ins = ins.map((input) => {
                  input = clone.parseInput(input);
                  if (input.type === "poly") {
                    return input.ins[i % input.ins.length];
                  }
                  return input;
                });
                return clone;
              });
          }
        }
      };
      Node.prototype.parseInput = function (input) {
        if (typeof input === "function") {
          input = input(this); // lambda feedback
        }
        if (Array.isArray(input)) {
          input = poly(...input);
        }
        return input;
      };
    </script>
    <!-- Node.run -->
    <script id="node-run">
      Node.prototype.run = function (visited = [], results = []) {
        if (visited.includes(this)) {
          return results[this.id] ?? 0;
        }
        // run children (depth first)
        const args = this.ins.map((input) => {
          if (input instanceof Node) {
            return input.run([...visited, this], results);
          }
          return input;
        });
        // pass children results to update
        const result = this.update(...args);
        results[this.id] = result;
        return result;
      };
      codeblock(document.currentScript, 8);
    </script>
    <!-- Node.step -->
    <script>
      Node.prototype.step = function* (visited = [], results = []) {
        if (visited.includes(this)) {
          return results[this.id] ?? 0;
        }
        yield this;
        let args = [];
        let isLeaf = true;
        visited.push(this);
        for (let input of this.ins) {
          if (input instanceof Node) {
            isLeaf = false;
            yield* input.step(visited, results);
            const arg = input.run(visited, results);
            args.push(arg);
          } else {
            args.push(input);
          }
        }
        this.args = args;
        const result = this.update(...args);
        results[this.id] = result;
        if (!isLeaf) {
          yield this;
        }
        //results[this.id] = result;
      };
      //codeblock(document.currentScript, 8);
    </script>
    <script id="math-nodes">
      // register some nodes
      let add = registerFn("add", (a, b) => a + b);
      let sub = registerFn("sub", (a, b) => a - b);
      let mul = registerFn("mul", (a, b) => a * b);
      let div = registerFn("div", (a, b) => a / b);
      let mod = registerFn("mod", (a, b) => a % b);
      let out = registerFn("out", (a) => a);
      let n = registerFn("n", (a) => a);
    </script>
    <!-- topoSort -->
    <script>
      // sort nodes by dependencies (using generator function to be able to step through)
      function* topoSort(node, visited = new Set()) {
        if (!(node instanceof Node) || visited.has(node)) {
          return; // constant values or already visited nodes
        }
        visited.add(node);
        for (let input of node.ins) {
          yield* topoSort(input, visited);
        }
        yield node;
      }
    </script>
  </head>
  <body>
    <div class="logo">
      <img src="./img/kabelsalat_logo_scrot.png" />
    </div>
    <section>
      <h1>kabelsalat</h1>
      <p>graph based language for live coding on the web and beyond</p>
      <p>a project started on june 7, 2024 -> almost 1 year in the making</p>
      <p>paper by felix roos and raphael forment</p>
    </section>
    <section>
      <h2>kabelsalat is a..</h2>
      <ul>
        <li>1. graph based</li>
        <li>2. language</li>
        <li>3. for</li>
        <li>4. audio</li>
        <li>5. visual</li>
        <li>6. livecoding</li>
        <li>7. on the web</li>
        <li>8. and beyond</li>
      </ul>
    </section>
    <section>
      <h2>1. graph based</h2>
      <!-- ![graph](./img/pd_graph.png) -->
      <p><img src="./img/nc_graph2.png" alt="graph" /></p>
      <!-- ![graph](./img/ks_graph.png) -->
      <ul>
        <li>
          you&#39;ve seen patch based interfaces Pure Data, Max, cables.gl,
          noisecraft.. or modular synths
        </li>
        <li>modules + cables = graph</li>
        <li>each module has inputs and one or more outputs</li>
      </ul>
      <pre>Saw 55 -> Filter 0.5 -> AudioOut</pre>
    </section>
    <section>
      <h2>2. language</h2>
      <img
        src="./img/hydra_chaining.jpg"
        alt="hydra chaining"
        style="margin-top: -140px; width: 800px"
      />
    </section>
    <section>
      <h2>2. language</h2>
      <!-- <p>module = function, cable = data flow</p> -->
      <p>
        <img src="./img/lang_graphviz.svg" alt="lang graph" width="500px" />
      </p>
      <p>
        <img src="./img/lang_unnested.png" alt="lang unnested" width="500px" />
      </p>
      <p><img src="./img/lang_nested.png" alt="lang nested" width="500px" /></p>
      <p>
        <img src="./img/lang_imperative.png" alt="lang nested" width="500px" />
      </p>
      <!-- <pre>out(lpf(saw(55), 200))</pre>
      <pre>saw(55).lpf(200).out()</pre>
      <pre>
r[0] = saw(55)
r[1] = lpf(r[0], 200)
out(r[1])</pre
      > -->
    </section>
    <!-- <section>
      <h2>2. language</h2>
      <h3>Node class</h3>
      <script>
        codeblock(document.querySelector("#node-class"), 8);
      </script>
    </section>
    <section>
      <h2>2. language</h2>
      <h3>run method</h3>
      <script>
        codeblock(document.querySelector("#node-run"), 8);
      </script>
    </section> -->
    <!-- <section>
      <h2>2. language</h2>
      <script>
        codeblock(document.querySelector("#math-nodes"), 6);
      </script>
      <details>
        <summary>show implementation</summary>
        <script>
          codeblock(document.querySelector("#node-class"), 6);
        </script>
      </details>
    </section> -->
    <section>
      <h2>2. language</h2>
      <p>a simple chain:</p>
      <node-garden rows="3">return add(4, 2).mul(3).div(2).out()</node-garden>
    </section>
    <section>
      <h2>2. language</h2>
      <p>without method chaining:</p>
      <node-garden rows="3">return out(div(mul(add(4, 2), 3), 2))</node-garden>
      <!-- <p>we can mix and match method chaining and regular functions:</p>
      <pre>a.b(c) === b(a, c)</pre> -->
    </section>
    <section>
      <h2>2. language</h2>
      <p>we can reuse nodes using variables:</p>
      <node-garden rows="3">
        <!--
let a = add(1, 2)
return a.mul(3).add(a).out()
          -->
      </node-garden>
    </section>
    <section>
      <h2>2. language</h2>
      <p>tree walking:</p>
      <node-garden rows="3">
        <!--
return add(8,2).mul( add(3,5) )
.mul( add(2,3).mul(4) ).out()
-->
      </node-garden>
    </section>
    <section>
      <h2>2. language</h2>
      <p>multichannel expansion:</p>
      <node-garden rows="3">
        <!--
return add([2, 3], 1).mul(4)
      -->
      </node-garden>
    </section>
    <section>
      <h2>2. language</h2>
      <p>channel matching:</p>
      <node-garden rows="3">
        <!--
return add([2, 3], 1).mul([4, 5])
      -->
      </node-garden>
    </section>
    <section>
      <h2>2. language</h2>
      <p>feedback:</p>
      <node-garden rows="3">
        <!--
const node = add(1)
node.ins.push(node)
return node.out()
      -->
      </node-garden>
    </section>
    <section>
      <h2>2. language</h2>
      <p>feedback with lambdas:</p>
      <node-garden rows="3">
        <!--
return add(1, o=>o).out()
      -->
      </node-garden>
      <!-- <details>
        <summary>show implementation</summary>
        <script>
          codeblock(document.querySelector("#node-feedback"), 6);
        </script>
      </details> -->
    </section>
    <section>
      <h2>2. language</h2>
      <p>multichannel expansion + feedback:</p>
      <node-garden rows="3">
        <!--
return add([2, 3], o=>o)
      -->
      </node-garden>
    </section>
    <!-- <section>
      <h2>2. for</h2>
      <pre></pre>
    </section> -->
    <section>
      <h2>3. audio</h2>
      <p>dsp-repl, without kabelsalat:</p>
      <dsp-repl rows="6"
        ><!-- 
$.dsp = (t) => {
  $.l = $.r = sin(241*t*2*PI)/4
}
--></dsp-repl
      >
      <ul>
        <li>the $.dsp function runs for every sample = 48kHz</li>
        <li>$.l and $.r hold the speaker position between -1 and 1</li>
      </ul>
    </section>
    <section>
      <h2>3. audio</h2>
      <p>bytebeat example:</p>
      <dsp-repl rows="7"
        ><!-- 
$.dsp = () => {
  let t = $.t
  $.l = $.r = ((( // ryg 2011-10-10
((t*("36364689"[t>>13&7]&15))/12&128)+(((((t>>12)^(t>>12)-2)%11*t)/4|t>>13)&127)
) & 255) / 127.5 - 1)/4
}
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>with kabelsalat:</p>
      <dsp-repl rows="6"
        ><!--
let node = sine(241).div(4).viz()

$.dsp = (t) => {
  $.l = $.r = node.run()
}
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>play function:</p>
      <dsp-repl rows="6"
        ><!--
Node.prototype.play = function() {
  this.viz()
  $.dsp = (t) => ($.l = $.r = this.run())
}
sine(241).div(4).play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>play function:</p>
      <dsp-repl rows="6"
        ><!--
sine(241).div(4).play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>multichannel expansion:</p>
      <dsp-repl rows="6"
        ><!--
saw([120,121])
.lpf(sine(2).range(.2,.8))
.div(2)
.group(1, 1, 1)
.play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>group:</p>
      <dsp-repl rows="6"
        ><!--
sine(60)
.div(4)
.group(4, 1, 1)
.play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>stress test:</p>
      <dsp-repl rows="6"
        ><!--
sine(random()*800+100)
.group(1000, .1, .1)
.div(100)
.play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p>with kabelsalat:</p>
      <dsp-repl rows="6"
        ><!--
saw(120)
.lpf(sine(2).range(.2,.8))
.div(2)
.group(1, .5)
.play()
--></dsp-repl
      >
    </section>
    <section>
      <h2>3. audio</h2>
      <p><img src="./img/nathan_ho_kick.png" alt="nathan ho kick" /></p>
      <pre>
sine(60)
.perc(.001, .3)
.mul(.4)
.pan(sine(.4))
.out()</pre
      >
      <dsp-repl rows="6"
        ><!-- 
sine(61)
.range(200,400)
.sine()
.div(4)
.play()
--></dsp-repl
      >

      <dsp-repl rows="8"
        ><!-- 
$.m ??= 0
$.m = ($.m+5)%24
let f = midi2freq($.m+60)
sine(f)
.div(4)
.mul(sine(2).range(.5,1))
.group(3, .01, .5).play()
-->
      </dsp-repl>
    </section>

    <section>
      <dsp-repl rows="8"
        ><!-- 
$.mem ??= new Float32Array(8)
let node = add(1,o=>o).mul(121/$.SR)
.mod(1).sub(0.5)
.compile($.mem)
$.dsp = (t) => {
  $.l = $.r = node.run()
}
-->
      </dsp-repl>
    </section>
    <section>
      <ul>
        <li>
          <p>
            <a href="https://garten.salat.dev/kabelsalat/graph-language.html"
              >a graph language</a
            >
          </p>
        </li>
        <li><p>show Node data structure</p></li>
        <li>talk about mondo?</li>
      </ul>
    </section>
    <script>
      const slides = Array.from(document.querySelectorAll("section"));
      let slideIndex = Number(window.location.hash.slice(1)) || 0;
      let setSlideIndex = (index) => {
        slideIndex = index % slides.length;
        console.log("slideIndex", slideIndex);
        slides.forEach((slide, i) => {
          //slide.style.display = "none";
          if (i < slideIndex) {
            /* slide.style.transform = "translate(-100vw)"; */
            slide.style.opacity = "0";
            slide.style.pointerEvents = "none";
          } else if (i === slideIndex) {
            /* slide.style.transform = "translate(0px,0px)"; */
            slide.style.opacity = "1";
            //slide.style.display = "flex";
            slide.style.pointerEvents = "inherit";
          } else if (i > slideIndex) {
            /* slide.style.transform = "translate(100vw)"; */
            slide.style.opacity = "0";
            slide.style.pointerEvents = "none";
          }
          // slide.style.display = "none";
        });
        const slide = slides[slideIndex];
        // slide.style.display = "flex";
        window.location.hash = slideIndex;
      };
      setSlideIndex(slideIndex);
      let nextSlide = () => setSlideIndex((slideIndex + 1) % slides.length);
      let prevSlide = () =>
        setSlideIndex((slideIndex - 1 + slides.length) % slides.length);
      window.nextSlide = nextSlide;
      window.prevSlide = prevSlide;
      document.onkeydown = (e) => {
        if (e.ctrlKey) {
          if (e.key === "ArrowLeft") {
            prevSlide();
          } else if (e.key === "ArrowRight") {
            nextSlide();
          }
        }
      };
    </script>
  </body>
</html>
