<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>iclc 2025: kabelsalat</title>
    <link
      rel="icon"
      type="image/png"
      href="https://kabel.salat.dev/favicon.png"
    />
    <style>
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        overflow: hidden;
      }
      body {
        background-color: #1d1918;
        margin: auto;
        font-family: monospace;
        font-size: 1.2em;
        color: #edd;
        padding: 20px 8px;
        padding: 0;
      }
      .logo {
        background: #1d1918;
        z-index: 2000;
        display: flex;
        top: 0;
        left: 20px;
        width: 80px;
        position: absolute;
        align-items: flex-end;
        img {
          height: 50px;
        }
      }
      .chapters {
        img {
          width: 200px;
        }
        font-size: 0.8em;
        h1 {
          margin: 0;
          opacity: 0.4;
          &.active {
            opacity: 1;
            /* text-decoration: underline; */
          }
        }
        &:not(.centered) {
          position: fixed;
          top: 80px;
          left: 20px;
        }
        .centered {
          img {
            display: none;
          }
        }
      }
      .hero {
        margin-top: -120px;
        width: 800px;
        max-width: 100%;
      }
      button {
        background: #222;
        border: 2px solid #555;
        color: white;
        font-size: 1em;
        padding: 2px 4px 4px 4px;
        cursor: pointer;
        &:hover {
          background: #333;
        }
        &:active {
          background: #666;
        }
      }
      node-garden,
      dsp-repl,
      node-viz,
      details {
        width: 100%;
        max-width: 800px;
      }
      section {
        * {
          flex-shrink: 0;
          max-width: 800px;
        }
        position: absolute;
        top: 0;
        left: 0;
        transition: all 0.5s ease-in-out;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 40px 20px;
        width: 100%;
        font-size: 1.5em;
        img {
          max-width: 100%;
        }
        padding-bottom: 500px;
        padding-left: 240px;
        opacity: 0;
        width: 100%;
        height: 100%;
        /* padding-bottom: 500px; */
        overflow: auto;
        h1,
        h2,
        h3 {
          /* position: sticky; */
          top: 0px;
          padding: 8px;
          z-index: 1000;
          background: #1d1918;
          margin-bottom: 20px;
        }
      }
      @media screen and (max-width: 1000px) {
        .chapters {
          display: none;
        }
        section {
          padding: 90px 20px;
        }
      }
      @font-face {
        font-family: "FontWithASyntaxHighlighter";
        src: url("./FontWithASyntaxHighlighter-Regular.woff2") format("woff2");
      }
      a {
        color: cyan;
        font-size: 1em;
      }
      textarea,
      pre:not(.pristine) {
        box-sizing: border-box;
        font-family: "FontWithASyntaxHighlighter", monospace;
        padding: 8px;
        font-size: 0.8em;
        border: 0;
        outline: none;
        overflow: auto;
        background-color: #44444490;
        color: white;
        width: 100%;
        margin: 8px 0;
        box-sizing: border-box;
        max-width: 800px;
      }
      pre.pristine {
        margin: 16px;
        font-family: monospace;
        font-size: 1.5em;
      }
      #lines {
        height: 200px;
      }
    </style>
    <!-- codeblock -->
    <script>
      // render codeblock from script tag
      let codeblock = (scriptElement, indent = 0) => {
        const script = document.currentScript;
        const pre = document.createElement("pre");
        pre.textContent = getCode(scriptElement, indent);
        script.after(pre);
      };
      function getCode(scriptElement, indent = 0) {
        return scriptElement.innerText
          .split("\n")
          .map((line) => line.slice(indent))
          .filter((x) => x && !x.startsWith("codeblock("))
          .join("\n");
      }
    </script>
    <!-- node-garden -->
    <script>
      class CloneTemplate extends HTMLElement {
        static observedAttributes = ["tid"];
        init() {
          const template = document.getElementById(this.getAttribute("tid"));
          const clone = template.content.cloneNode(true);
          const container = document.createElement("div");
          container.appendChild(clone);
          this.appendChild(container);
        }
        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
      }
      customElements.define("clone-template", CloneTemplate);

      class NodeViz extends HTMLElement {
        static observedAttributes = ["code", "dir", "height"];
        init() {
          const container = document.createElement("div");
          container.style.height = this.getAttribute("height");
          container.style.width = "100%";
          this.code = this.getAttribute("code");
          const dir = this.getAttribute("dir") ?? "LR";
          const node = new Function(this.code)();
          renderNode(
            node,
            container,
            (gvnode, node) => {
              gvnode.color = node.color || "white";
              return gvnode;
            },
            (edge) => edge,
            dir
          );
          this.appendChild(container);
        }
        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
      }
      customElements.define("node-viz", NodeViz);

      class NodeGarden extends HTMLElement {
        static observedAttributes = ["code", "rows"];
        init() {
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "")
              .replace("<!--", "")
              .replace("-->", "")
              .trim() ||
            "";
          this.innerHTML = "";
          const rows = this.getAttribute("rows") ?? 6;

          this.insertAdjacentHTML(
            "beforeend",
            `
      <div style="padding:0;width:100%">
        <div class="viz" style="display:flex;justify-content:center;padding:10px;height:220px;margin:10px"></div>
        <textarea id="code" spellcheck="false" rows="${rows}" style="margin:0;border-bottom:2px solid #222;width:100%;font-size:.8em"></textarea>
        <div style="position:relative">
          <pre class="result"></pre>
          
          <div style="display:flex;position:absolute;right:0;top:0">
            <button style="margin-right:8px" class="run">run</button>
            <button style="margin-right:8px" class="reset">reset</button>
            <button class="step">step</button>
            <button class="contract">-</button>
            <button class="expand">+</button>
          </div>
        </div>
        <details>
          <summary>show json</summary>
          <pre class="json" ></pre>
        </details>
        <details>
          <summary>show steps</summary>
          <pre class="steps"></pre>
        </details>
      </div>`
          );
          // repl logic
          const input = this.querySelector("textarea");
          this.result = this.querySelector(".result");
          this.steps = this.querySelector(".steps");
          this.vizContainer = this.querySelector(".viz");
          this.runButton = this.querySelector(".run");
          this.stepButton = this.querySelector(".step");
          this.resetButton = this.querySelector(".reset");
          this.contractButton = this.querySelector(".contract");
          this.expandButton = this.querySelector(".expand");
          input.value = code;
          this.input = input;
          this.reset();

          this.stepButton.addEventListener("click", () => this.step());
          this.runButton.addEventListener("click", () => this.update());
          this.resetButton.addEventListener("click", () => this.reset());
          this.contractButton.addEventListener("click", () => this.contract());
          this.expandButton.addEventListener("click", () => this.expand());

          input.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              this.update();
            } else if ((e.ctrlKey || e.altKey) && e.key === ".") {
              e.preventDefault();
              this.stop();
            }
          });
        }
        setCode(code) {
          this.code = code;
          this.input.value = code;
          this.update();
        }
        reset() {
          this.results = [];
          this.update();
          this.results = []; // maybe this is not needed..
          this.currentNode = null;
          this.visited = [];
          delete this.stepper;
          this.steps.innerText = "// click step to start walking";
          // this.render();
        }
        render() {
          renderNode(this.node, this.vizContainer);
        }
        nodeColor(node) {
          const cid = this.currentNode?.id;
          if (node.id === cid) {
            return "magenta";
          }
          if (this.results[node.id] !== undefined) {
            return "cyan";
          }
          if (this.visited.find((v) => v.id === node.id)) {
            return "yellow";
          }
          return "white";
        }
        renderStepped() {
          const cid = this.currentNode?.id;
          renderNode(
            this.node,
            this.vizContainer,
            (node) => {
              node.color = this.nodeColor(node);
              const n = this.nodes[node.id];
              return node;
            },
            (edge) => {
              const source = this.nodes[edge.source];
              const target = this.nodes[edge.target];
              const argIndex = target.ins.findIndex(
                (input) => input.id === edge.source
              );
              const sourceColor = this.nodeColor(source);
              const targetColor = this.nodeColor(target);

              if (edge.target === cid) {
                edge.color = "magenta";
              } else if (sourceColor === "cyan") {
                edge.color = "cyan";
              } else if (this.visited.find((v) => v.id === edge.target)) {
                edge.color = "yellow";
              }
              const hasResult = this.results[edge.source] !== undefined;
              if (!hasResult && ["magenta"].includes(edge.color)) {
                edge.label = "?";
              } else if (["yellow"].includes(edge.color)) {
                edge.label = "?";
              } else if (edge.target <= cid || cid === undefined) {
                edge.label = target.args?.[argIndex] ?? "";
              } else {
                edge.label = this.results[edge.source] ?? "";
              }
              return edge;
            }
          );
        }
        evaluate() {
          const fn = new Function("self", this.input.value);
          this.node = fn(this);
          this.nodes = Array.from(topoSort(this.node));
          this.nodes.forEach((node, i) => {
            node.id = i;
          });
          try {
            this.querySelector(".json").innerText = JSON.stringify(
              this.node,
              null,
              2
            );
          } catch (err) {}
        }
        async update() {
          // this.results = []; // clear state
          expansions = 0;
          this.evaluate();
          this.render();
          this.result.innerText = `= ${this.node.run([], this.results)}`;
        }
        step() {
          if (!this.stepper) {
            this.visited = [];
            //this.results = []; // uncomment to disable feedback
            this.stepper = this.node.step(this.visited, this.results);
            this.result.innerText = "= ?";
          }
          const next = this.stepper.next();
          this.currentNode = next.value;
          const cid = this.currentNode?.id;

          this.renderStepped();
          const calculations =
            this.results
              .map((result, i) => {
                const n = this.nodes[i];
                if (!this.visited.includes(n) || n.id >= cid) {
                  return "";
                }
                //const output = result
                const output = cid < i ? "?" : result ?? "??";
                return `r[${i}] = ${n.type}(${n.ins
                  .map((input, i) =>
                    input instanceof Node ? `r[${input.id}]` : input
                  )
                  .join(", ")}) = ${output}`;
              })
              .filter(Boolean)
              .join("\n") || `// searching computable nodes`;
          this.steps.innerText = calculations;
          if (!this.currentNode) {
            this.result.innerText = `= ${
              this.results[this.results.length - 1]
            }`;
            delete this.stepper;
            return;
          }
        }
        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          if (name === "code") {
            this.setCode(newValue);
          }
        }
        contract() {
          this.renderExpansion(expansion - 1);
        }
        expand() {
          this.renderExpansion(expansion + 1);
        }
        renderExpansion(_expansion = 0) {
          expansion = Math.max(_expansion, 0);
          expansion = Math.min(expansion, nextExpansion);
          expansions = 0;
          this.evaluate();
          let nodes = Array.from(topoSort(this.node));
          renderNode(this.node, this.vizContainer, (gvnode) => {
            const node = nodes[gvnode.id];
            if (node.type === "poly") {
              gvnode.color = "orchid";
            } else if (node.ins.find((input) => input?.type === "poly")) {
              gvnode.color = "cyan";
            }
            return gvnode;
          });

          if (!nodes.slice(0, -1).find((node) => node.type === "poly")) {
            nextExpansion = expansion; // cannot step more
            console.log("done expanding");
          } else {
            nextExpansion = expansion + 1; // at least one more...
          }
        }
      }
      customElements.define("node-garden", NodeGarden);
    </script>
    <!-- graphviz -->
    <script>
      function gvjson2dot(json, dir = "LR") {
        const { nodes, edges } = json;
        let renderProps = (props) =>
          `[${Object.entries(props)
            .map(([key, value]) => `${key}="${value}"`)
            .join(",")}]`;
        return `digraph {
            bgcolor="transparent";
            rankdir="${dir}";
            node [penwidth=4];
            edge [penwidth=2];
            ${nodes
              .map((node) => `  "${node.id}" ${renderProps(node)}`)
              .join("\n")}
            ${edges
              .map(
                (edge) =>
                  `  ${edge.source} -> ${edge.target} ${renderProps(edge)}`
              )
              .join("\n")}
            }`;
      }
      const numberTypes = ["n", "float"]; // hydra
      function node2gvjson(graph, editNode, editEdge) {
        const nodes = [],
          edges = [];

        let style = {
          color: "white",
          fontcolor: "white",
          fontsize: "10",
          fontname: "monospace",
        };
        const sorted = Array.from(topoSort(graph)).map((node, i) => {
          node.id = i;
          return node;
        });
        sorted.forEach((node, i) => {
          if (numberTypes.includes(node.type)) {
            return;
          }
          node.id = i;
          const label = `${node.type} ${node.ins
            .map((input) => {
              if (numberTypes.includes(input.type)) {
                input = input.value;
              }
              if (typeof input === "number") {
                return Math.round(input * 10000) / 10000;
              }
              return "_";
            })
            .join(" ")}`;
          let gvnode = {
            id: node.id,
            label,
            ordering: "in",
            width: "0.5",
            height: "0.4",
            ...style,
          };
          if (editNode) {
            gvnode = editNode(gvnode, node, i);
          }
          nodes.push(gvnode);
          for (let i in node.ins) {
            if (
              typeof node.ins[i] !== "object" ||
              numberTypes.includes(node.ins[i].type)
            ) {
              continue;
            }
            if (node.ins[i].id === undefined) {
              console.log("undefined source id", node.ins[i], "for node", node);
            }
            let gvedge = {
              label: "",
              id: edges.length,
              source: node.ins[i].id ?? "whuuuat",
              target: node.id,
              directed: "true",
              ...style,
            };
            if (editEdge) {
              gvedge = editEdge(gvedge, node, i);
            }
            edges.push(gvedge);
          }
          return node;
        });
        return { nodes, edges };
      }
      function node2dot(node, editNode, editEdge, dir) {
        const flat = node2gvjson(node, editNode, editEdge);
        const dot = gvjson2dot(flat, dir);
        return dot;
      }
      async function renderDot(dot, container) {
        // this breaks my rule of self-contained html :/
        // but graphviz is just so good..
        // i don't want to segway into graph layouting rn...
        // download the file here: https://unpkg.com/@hpcc-js/wasm@2.18.0/dist/graphviz.js
        // sorry if you're living in 2051 and npm has collapsed already..
        const { Graphviz } = await import("./graphviz.js");
        const graphvizLoaded = Graphviz.load();
        const graphviz = await graphvizLoaded;
        const svg = await graphviz.layout(dot, "svg", "dot", {});
        const base64 = btoa(unescape(encodeURIComponent(svg)));
        const dataUrl = `data:image/svg+xml;base64,${base64}`;
        const img = document.createElement("img");
        img.src = dataUrl;
        /* img.style.maxHeight = "200px"; */
        img.style.width = "100%";
        container.innerText = "";
        container.appendChild(img);
      }
      function nodes2gvjson(nodes, editNode, editEdge) {
        const gvnodes = [],
          gvedges = [];

        let style = {
          color: "white",
          fontcolor: "white",
          fontsize: "10",
          fontname: "monospace",
        };
        let getInput = (input) => {
          if (typeof input === "string") {
            return nodes[Number(input)];
          }
          return input;
        };
        nodes.forEach((node, i) => {
          const ins = node.ins.map(getInput);
          const label = `${node.type} ${ins
            .map((input) =>
              typeof input === "object"
                ? "_"
                : Math.round(input * 10000) / 10000
            )
            .join(" ")}`;
          let gvnode = {
            id: node.id,
            label,
            ordering: "in",
            width: "0.5",
            height: "0.4",
            ...style,
          };
          if (editNode) {
            gvnode = editNode(gvnode, node, i);
          }
          gvnodes.push(gvnode);
          for (let i in ins) {
            if (typeof ins[i] !== "object") {
              continue;
            }
            if (ins[i].id === undefined) {
              console.log("undefined source id", ins[i], "for node", node);
            }
            let gvedge = {
              label: "",
              id: gvedges.length,
              source: ins[i].id ?? "whuuuat",
              target: node.id,
              directed: "true",
              ...style,
            };
            if (editEdge) {
              gvedge = editEdge(gvedge);
            }
            gvedges.push(gvedge);
          }
          return node;
        });
        return { nodes: gvnodes, edges: gvedges };
      }
      function renderNode(node, container, editNode, editEdge, dir) {
        const dot = node2dot(node, editNode, editEdge, dir);
        return renderDot(dot, container);
      }
      function nodes2dot(nodes, editNode, editEdge) {
        const flat = nodes2gvjson(nodes, editNode, editEdge);
        const dot = gvjson2dot(flat);
        return dot;
      }
      function renderNodes(nodes, container, editNode, editEdge) {
        const dot = nodes2dot(nodes, editNode, editEdge);
        return renderDot(dot, container);
      }
    </script>
    <!-- dsp-worklet -->
    <template class="dsp-worklet">
      <script>
        class DspProcessor extends AudioWorkletProcessor {
          dsp = () => {};
          l = 0;
          r = 0;
          SR = sampleRate;
          ISR = 1 / sampleRate;
          constructor() {
            super();
            this.t = 0;
            this.S = 0;
            this.active = true;
            this.frames = Math.floor(sampleRate / 30);
            this.framebuffers = [
              new Float32Array(this.frames),
              new Float32Array(this.frames),
            ];
            this.msg = {
              framebuffers: this.framebuffers,
            };
            globalThis.$ = this;
            this.port.onmessage = (e) => {
              const msg = e.data;
              if (msg && msg.code) {
                //new Function("$", msg.code)(this);
                new Function(msg.code)();
              } else if (msg === "stop") {
                this.active = false;
              }
            };
          }
          process(inputs, outputs, parameters) {
            const output = outputs[0];
            for (let i = 0; i < output[0].length; i++) {
              this.dsp(this.t / sampleRate);
              output[0][i] = this.l;
              output[1][i] = this.r;
              this.t++;
              this.S = this.t * this.ISR;
              this.framebuffers[0][this.t % this.frames] = this.l;
              this.framebuffers[1][this.t % this.frames] = this.r;
              if (this.t % this.frames === 0 && this.t > 0) {
                this.port.postMessage(this.msg);
              }
            }
            return this.active;
          }
        }
      </script>
    </template>
    <!-- dsp-repl -->
    <script>
      const ctx = new AudioContext();
      // init audio context
      document.addEventListener("click", function firstClick() {
        ctx.resume(); // autoply policy
        document.removeEventListener("click", firstClick);
      });

      const _lerp = (v, min, max) => v * (max - min) + min;
      const invLerp = (v, min, max) => (v - min) / (max - min);
      const remap = (v, vmin, vmax, omin, omax) =>
        _lerp(invLerp(v, vmin, vmax), omin, omax);

      class DSPRepl extends HTMLElement {
        static observedAttributes = [
          "code",
          "rows",
          "next",
          "viz",
          "font-size",
        ];
        worklet;
        init() {
          let fontSize = this.getAttribute("font-size") ?? 24;
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "").replace("<!--", "").replace("-->", "").trim();

          const rows = this.getAttribute("rows") ?? 4;
          if (!code) {
            return;
          }
          this.innerHTML = "";
          this.insertAdjacentHTML(
            "beforeend",
            `<div style="border:0px solid #222;padding:0;position:relative">
            <textarea spellcheck="false" rows="${rows}"></textarea>
            <div style="user-select:none;cursor:pointer;position:absolute;top:0;right:0">
            <button class="play">run</button> <button class="stop">stop</button>
            </div>
            <details class="steps-details" style="opacity:0">
              <summary>show compiled output</summary>
              <pre class="steps"></pre>
            </details>
            <canvas width="400" height="80"></canvas>
            ${
              !!this.getAttribute("viz")
                ? `
              <div
                class="viz"
                style="display:flex;justify-content:center;padding:10px"
              ></div>`
                : ""
            }
          </div>`
          );
          // draw logic
          this.vizContainer = this.querySelector(".viz");
          this.stepsDetails = this.querySelector(".steps-details");
          this.stepsContainer = this.querySelector(".steps");
          this.canvas = this.querySelector("canvas");
          this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;
          this.canvas.height =
            this.canvas.clientHeight * window.devicePixelRatio;
          this.drawContext = this.canvas.getContext("2d");
          this.drawSilence(this.drawContext);

          // repl logic
          const input = this.querySelector("textarea");
          input.value = code;
          input.style = `margin:0;border-bottom:2px solid #222;font-size:${fontSize}px`;
          this.input = input;

          this.querySelector(".play").onclick = () => this.update(input.value);
          this.querySelector(".stop").onclick = () => this.stop();
          input.addEventListener("keydown", async (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              const hash = btoa(input.value);
              let urlCode = window.location.hash.slice(1);
              this.update(input.value);
            }
            if ((e.ctrlKey || e.altKey) && e.code === "Period") {
              e.preventDefault();
              this.stop();
            }
          });
        }
        async initWorklet() {
          if (this.worklet) {
            return;
          }
          await ctx.resume();
          this.worklet = await this.runWorklet(ctx, this.input.value);
          this.worklet.port.onmessage = (e) => {
            if (e.data.framebuffers) {
              const [l, r] = e.data.framebuffers;
              requestAnimationFrame(() => {
                this.drawBuffer(l, [-4, 1]);
                this.drawBuffer(r, [-1, 4], false);
              });
            } else if (e.data.viz) {
              const nodes = JSON.parse(e.data.viz);
              this.vizContainer &&
                renderNodes(nodes, this.vizContainer, (gvnode, node) => {
                  if (node.type === "fadeout") {
                    gvnode.color = "red";
                  } else if (node.type === "fadein") {
                    gvnode.color = "green";
                  }
                  return gvnode;
                });
            } else if (e.data.code && this.stepsContainer) {
              this.stepsDetails.style.opacity = 1;
              this.stepsContainer.innerText = `// this runs for every sample:\n${e.data.code}`;
            }
          };
        }

        async update(code) {
          await this.initWorklet();
          /* console.log("update:::", code); */
          if (this.getAttribute("next")) {
            globalThis.$ = this;
            const fn = new Function(code)();
          } else {
            this.worklet.port.postMessage({ code });
          }
        }
        stop() {
          this.worklet?.disconnect();
          this.worklet?.port.postMessage("stop");
          if (typeof $ !== "undefined") {
            delete $.n;
            delete $.nodes;
          }
          this.worklet = undefined;
        }

        async runWorklet(ac) {
          const name = `worklet-${Date.now()}`;
          const math = Object.getOwnPropertyNames(Math).join(",");
          let prelude = `const {${math}} = Math;\nObject.assign(globalThis,{${math}})\n`;
          // add dsp scripts
          document
            .querySelector("template.dsp-prelude")
            .content.querySelectorAll("script")
            .forEach((script) => {
              prelude += script.textContent;
            });

          let workletCode = document
            .querySelector("template.dsp-worklet")
            .content.querySelector("script").textContent;

          workletCode = `${prelude}\n${workletCode}\nregisterProcessor('${name}', DspProcessor);`;

          await ac.resume();
          const dataURL = `data:text/javascript;base64,${btoa(workletCode)}`;
          await ac.audioWorklet.addModule(dataURL);
          const node = new AudioWorkletNode(ac, name, {
            outputChannelCount: [2],
          });
          node.connect(ac.destination);
          return node;
        }

        drawBuffer(samples, range = [-1, 1], clear = true) {
          clear &&
            this.drawContext.clearRect(
              0,
              0,
              this.drawContext.canvas.width,
              this.drawContext.canvas.height
            );
          this.plot(
            (x) => samples[Math.floor(x)], // this is bad..
            this.drawContext,
            [1, samples.length],
            range,
            "white",
            2
          );
        }
        // plot function, see /plot.html
        plot(
          fn,
          ctx,
          xrange = [-1, 1],
          yrange = [-1, 1],
          color = "black",
          lineWidth = 4
        ) {
          // these 3 functions are very good to know..
          const lerp = (v, min, max) => v * (max - min) + min;
          const invLerp = (v, min, max) => (v - min) / (max - min);
          const remap = (v, vmin, vmax, omin, omax) =>
            lerp(invLerp(v, vmin, vmax), omin, omax);
          // prepare draw context
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color;
          // function ranges
          const [x0, x1] = xrange;
          const [y0, y1] = yrange;
          // draw ranges
          const [px0, px1] = [0, ctx.canvas.width];
          const [py0, py1] = [ctx.canvas.height - ctx.lineWidth, ctx.lineWidth];
          // actual draw logic
          ctx.beginPath();
          for (let px = 0; px < ctx.canvas.width; px++) {
            const x = remap(px, px0, px1, x0, x1);
            const y = fn(x);
            const py = remap(y, y0, y1, py0, py1);
            px === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
          }
          ctx.stroke();
        }
        drawSilence(ctx, color = "white", lineWidth = 2) {
          const canvas = ctx.canvas;
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height / 2);
          ctx.lineTo(canvas.width, canvas.height / 2);
          ctx.stroke();
        }

        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          this.init();
        }
      }
      customElements.define("dsp-repl", DSPRepl);
    </script>
    <template class="dsp-prelude">
      <!-- Node -->
      <script>
        // https://garten.salat.dev/kabelsalat/graph-computation.html
        class DspNode {
          constructor(type, ins, update, compileSelf) {
            this.type = type;
            update && (this.update = update);
            compileSelf && (this.compileSelf = compileSelf);
            this.ins = ins;
            this.expand();
          }
          run() {
            const args = this.ins.map((input) => {
              if (input instanceof Node) {
                return input.run();
              }
              return input;
            });
            return this.update(...args);
          }
        }

        globalThis.Node = DspNode;
        function compilePoly(r, args) {
          return `$.l=${args[0]}*0.3;$.r=${args[1] || args[0]}*0.3;`;
        }
        Node.prototype.parseInput = function (input) {
          if (typeof input === "function") {
            input = input(this); // lambda feedback
          }
          // multichannel expansion
          if (Array.isArray(input)) {
            input = poly(...input);
          }
          return input;
        };

        // multichannel expansion
        Node.prototype.expand = function () {
          let type = this.type,
            ins = this.ins,
            update = this.update,
            compileSelf = this.compileSelf;
          let maxExpansions = 0;
          this.ins = ins.map((input) => {
            input = this.parseInput(input);
            if (input.type === "poly") {
              maxExpansions = Math.max(maxExpansions, input.ins.length);
            }
            return input;
          });
          if (maxExpansions > 0) {
            this.type = "poly";
            this.update = (...args) => args;
            this.compileSelf = compilePoly;
            // make mono if only one channel

            this.ins = Array(maxExpansions)
              .fill(0)
              .map((_, i) => {
                const clone = new this.constructor(
                  type,
                  [],
                  update,
                  compileSelf
                );
                clone.ins = ins.map((input) => {
                  input = clone.parseInput(input);
                  if (input.type === "poly") {
                    return input.ins[i % input.ins.length];
                  }
                  return input;
                });
                return clone;
              });
          }
        };
        Node.prototype.compile = function (memory) {
          let nodes = Array.from(topoSort(this));
          // console.log(memory.join("\n"));
          let r = memory ? memory : Array(nodes.length).fill(0);
          const getRef = (input) =>
            typeof input !== "object" ? input : `r[${nodes.indexOf(input)}]`;
          let lines = [];
          for (let id in nodes) {
            const node = nodes[id];
            const args = node.ins.map(getRef);
            const ref = getRef(node);
            if (!node.compileSelf) {
              lines.push(`${ref} = n[${id}].update(${args.join(",")})`);
            } else {
              lines.push(node.compileSelf(ref, args, node, id));
            }
            lines[lines.length - 1] += ` // ${node.type}`;
          }
          const last = getRef(nodes[nodes.length - 1]);
          // lines.push(`return ${last}`);
          const code = lines.join("\n");
          console.log("-------compiled--------");
          console.log(code);
          const update = new Function("n", "r", code);
          const node = new Node("compiled", [], () => update(nodes, r));
          node.code = code;
          $.port.postMessage({ code: code });
          return node;
        };
        Node.prototype.viz = function () {
          try {
            const nodes = Array.from(topoSort(this));
            let flat = nodes.map((node, id) => ({
              id,
              type: node.type,
              ins: node.ins.map((input) =>
                input instanceof Node ? String(nodes.indexOf(input)) : input
              ),
            }));
            $.port.postMessage({ viz: JSON.stringify(flat) });
          } catch (err) {
            console.warn("non serializable node. probably because of feedback");
          }
          return this;
        };
        globalThis.register = (type, getNode) => {
          Node.prototype[type] = function (...args) {
            return getNode(this, ...args);
          };
          return getNode;
        };
        globalThis.registerFn = (type, update) =>
          register(type, (...args) => new Node(type, args, update));

        globalThis.registerClass = (type, NodeClass) =>
          register(type, (...args) => new NodeClass(type, args));

        globalThis.registerRaw = (type, compileSelf) =>
          register(type, (...args) => {
            const argNames = Array.from(
              { length: args.length },
              (_, i) => `a${i}`
            );
            const body = `${compileSelf("let v", argNames)}; return v;`;
            const update = new Function(...argNames, body);
            return new Node(type, args, update, compileSelf);
          });
        globalThis.poly = register(
          "poly",
          (...args) => new Node("poly", args, null, compilePoly)
        );
      </script>
      <!-- topoSort -->
      <script>
        // https://garten.salat.dev/kabelsalat/graph-compilation.html
        // sort nodes by dependencies (using generator function to be able to step through)
        function* topoSort(node, visited = new Set()) {
          if (!(node instanceof Node) || visited.has(node)) {
            return; // constant values or already visited nodes
          }
          visited.add(node);
          for (let input of node.ins) {
            yield* topoSort(input, visited);
          }
          yield node;
        }
      </script>
      <script id="play-method">
        Node.prototype.play = function () {
          this.viz();
          const out = polify(this); // we need a poly node at the end
          if (out.ins.length > 2) {
            console.warn("more than 2 channels! only using first 2");
          }
          // out.type = "out";
          let compiled = out.compile();
          $.dsp = () => compiled.run();
          return compiled;
        };
        Node.prototype.out = Node.prototype.play;
      </script>
      <script id="collect-method">
        Node.prototype.collect = function (max = 1) {
          $.nodes ??= [];
          $.nodes.push(this);
          $.nodes = $.nodes.slice(-max);
          return add(...$.nodes);
        };
      </script>
      <script id="group-method">
        globalThis.polify = register("polyify", (input) =>
          input.type === "poly" ? input : poly(input)
        );
        Node.prototype.group = function (max = 1, fadeIn = 0, fadeOut = 0.1) {
          $.nodes ??= [];
          let len = $.nodes.length;
          // fade out / retire old nodes

          $.nodes = $.nodes.reduce((acc, node, i) => {
            // assumes nodes is poly node with at least 1 channel
            const in0 = node.ins[0];
            //console.log("in0", in0);
            if (in0.type === "fadeout" && in0.done) {
              return acc; // omit already silent node
            }
            if (in0.type === "fadein" && in0.done) {
              // unwrap fadein node
              node.ins = node.ins.map((input) => input.ins[0]);
            }
            if (in0.type !== "fadeout" && len - i >= max) {
              if (!fadeOut) {
                return acc;
              }
              node = fadeout(node, fadeOut);
            }
            acc.push(node);
            return acc;
          }, []);

          // fade in new node
          let node = fadeIn ? this.fadein(fadeIn) : this;
          // make sure node is always poly (simplifies checks in reducer above)
          node = polify(node);
          $.nodes.push(node);
          return add(...$.nodes);
        };
        Node.prototype.spawn = function (max = 1, fadeIn = 1, fadeOut = 1) {
          return this.group(max, fadeIn, fadeOut).out();
        };
      </script>
      <script id="fade">
        // maybe these could be combined into a single Node
        class FadeIn extends Node {
          start = $.S;
          done = false;
          update(input, fadeTime = 1) {
            const progress = ($.S - this.start) / fadeTime;
            if (progress >= 1) {
              this.done = true;
              return input;
            }
            const gain = Math.min(1, progress);
            return input * gain;
          }
        }

        globalThis.FadeIn = FadeIn;
        globalThis.fadein = registerClass("fadein", FadeIn);
        class FadeOut extends Node {
          start = $.S;
          done = false;
          update(input, fadeTime = 1) {
            this.init = true;
            const progress = ($.S - this.start) / fadeTime;
            if (progress >= 1) {
              this.done = true;
              return 0;
            }
            const gain = 1 - Math.min(1, progress);
            return input * gain;
          }
        }
        globalThis.FadeOut = FadeOut;
        globalThis.fadeout = registerClass("fadeout", FadeOut);
      </script>
      <script>
        const ISR = 1 / sampleRate;
        // https://garten.salat.dev/audio-dsp/oscillators.html
        class SineOsc extends Node {
          phase = 0;
          update(freq) {
            const value = Math.sin(this.phase * 2 * Math.PI);
            this.phase = (this.phase + freq / sampleRate) % 1;
            return value;
          }
        }
        globalThis.SineOsc = SineOsc;
        globalThis.sine = registerClass("sine", SineOsc);

        class ZawOsc extends Node {
          phase = 0;
          update(freq) {
            this.phase += ISR * freq;
            return (this.phase % 1) * 2 - 1;
          }
        }
        globalThis.ZawOsc = ZawOsc;
        globalThis.zaw = registerClass("zaw", ZawOsc);

        function polyBlep(t, dt) {
          // 0 <= t < 1
          if (t < dt) {
            t /= dt;
            // 2 * (t - t^2/2 - 0.5)
            return t + t - t * t - 1;
          }
          // -1 < t < 0
          if (t > 1 - dt) {
            t = (t - 1) / dt;
            // 2 * (t^2/2 + t + 0.5)
            return t * t + t + t + 1;
          }
          // 0 otherwise
          return 0;
        }
        class SawOsc extends Node {
          //phase = Math.random();
          phase = 0;
          update(freq) {
            const dt = freq / sampleRate;
            let p = polyBlep(this.phase, dt);
            let s = 2 * this.phase - 1 - p;
            this.phase += dt;
            if (this.phase > 1) {
              this.phase -= 1;
            }
            return s;
          }
        }
        globalThis.SawOsc = SawOsc;
        globalThis.saw = registerClass("saw", SawOsc);

        class TriOsc extends Node {
          phase = 0;
          update(freq) {
            this.phase += ISR * freq;
            let phase = this.phase % 1;
            let value = phase < 0.5 ? 2 * phase : 1 - 2 * (phase - 0.5);
            return value * 2 - 1;
          }
        }
        globalThis.TriOsc = TriOsc;
        globalThis.tri = registerClass("tri", TriOsc);

        globalThis.mix = register("mix", (input, channels = 1) => {
          if (![1, 2].includes(channels)) {
            channels = 2;
            console.warn(
              "mix only supports 1 or 2 channels atm.. falling back to 2"
            );
          }
          if (input.type !== "poly") {
            return input;
          }
          if (channels === 2) {
            const panned = input.ins.map((channel, i, ins) => {
              // we can do this at eval time: channels are fixed!
              const pos = (i / (ins.length - 1)) * 2 - 1;
              const deg = ((pos + 1) * Math.PI) / 4;
              const stereo = channel.mul([Math.cos(deg), Math.sin(deg)]);
              return stereo;
            });
            return add(...panned);
          }
          return add(...input.ins);
        });

        class Lpf extends Node {
          s0 = 0;
          s1 = 0;
          update(s, cutoff, resonance = 0) {
            // Out of bound values can produce NaNs
            cutoff = Math.min(cutoff, 1);
            resonance = Math.max(resonance, 0);
            var c = Math.pow(0.5, (1 - cutoff) / 0.125);
            var r = Math.pow(0.5, (resonance + 0.125) / 0.125);
            var mrc = 1 - r * c;
            var v0 = this.s0;
            var v1 = this.s1;
            // Apply the filter to the sample
            v0 = mrc * v0 - c * v1 + c * s;
            v1 = mrc * v1 + c * v0;
            s = v1;
            this.s0 = v0;
            this.s1 = v1;
            return s;
          }
        }
        globalThis.Lpf = Lpf;
        globalThis.lpf = registerClass("lpf", Lpf);

        class PulseOsc extends Node {
          phase = 0;
          update(freq, duty = 0.5) {
            this.phase += ISR * freq;
            let cyclePos = this.phase % 1;
            return cyclePos < duty ? 1 : -1;
          }
        }
        globalThis.PulseOsc = PulseOsc;
        globalThis.pulse = registerClass("pulse", PulseOsc);

        class Dust extends Node {
          update = (density) =>
            Math.random() < density * ISR ? Math.random() : 0;
        }
        globalThis.Dust = Dust;
        globalThis.dust = registerClass("dust", Dust);

        class Impulse extends Node {
          phase = 1;
          update(freq) {
            this.phase += ISR * freq;
            let v = this.phase >= 1 ? 1 : 0;
            this.phase = this.phase % 1;
            return v;
          }
        }
        globalThis.Impulse = Impulse;
        globalThis.impulse = registerClass("impulse", Impulse);

        class ClockDiv extends Node {
          inSgn = true;
          outSgn = true;
          clockCnt = 0;
          update(clock, factor) {
            let curSgn = clock > 0;
            if (this.inSgn != curSgn) {
              this.clockCnt++;
              if (this.clockCnt >= factor) {
                this.clockCnt = 0;
                this.outSgn = !this.outSgn;
              }
            }

            this.inSgn = curSgn;
            return this.outSgn ? 1 : -1;
          }
        }
        globalThis.ClockDiv = ClockDiv;
        globalThis.clockdiv = registerClass("clockdiv", ClockDiv);

        globalThis.noise = registerRaw(
          "noise",
          (r) => `${r} = Math.random() * 2 - 1`
        );

        class Hold extends Node {
          value = 0;
          trigSgn = false;
          update(input, trig) {
            if (!this.trigSgn && trig > 0) this.value = input;
            this.trigSgn = trig > 0;
            return this.value;
          }
        }
        globalThis.Hold = Hold;
        globalThis.hold = registerClass("hold", Hold);

        function lerp(x, y0, y1) {
          if (x >= 1) return y1;

          return y0 + x * (y1 - y0);
        }

        class ADSR extends Node {
          state = "off";
          startTime = 0;
          startVal = 0;

          update(gate, attack, decay, susVal, release) {
            let curTime = $.S; // $.S = time in seconds
            switch (this.state) {
              case "off": {
                if (gate > 0) {
                  this.state = "attack";
                  this.startTime = curTime;
                  this.startVal = 0;
                }
                return 0;
              }
              case "attack": {
                let time = curTime - this.startTime;
                if (time > attack) {
                  this.state = "decay";
                  this.startTime = curTime;
                  return 1;
                }
                return lerp(time / attack, this.startVal, 1);
              }
              case "decay": {
                let time = curTime - this.startTime;
                let curVal = lerp(time / decay, 1, susVal);
                if (gate <= 0) {
                  this.state = "release";
                  this.startTime = curTime;
                  this.startVal = curVal;
                  return curVal;
                }
                if (time > decay) {
                  this.state = "sustain";
                  this.startTime = curTime;
                  return susVal;
                }
                return curVal;
              }
              case "sustain": {
                if (gate <= 0) {
                  this.state = "release";
                  this.startTime = curTime;
                  this.startVal = susVal;
                }
                return susVal;
              }
              case "release": {
                let time = curTime - this.startTime;
                if (time > release) {
                  this.state = "off";
                  return 0;
                }
                let curVal = lerp(time / release, this.startVal, 0);
                if (gate > 0) {
                  this.state = "attack";
                  this.startTime = curTime;
                  this.startVal = curVal;
                }
                return curVal;
              }
            }
            throw "invalid envelope state";
          }
        }
        globalThis.ADSR = ADSR;
        globalThis.adsr = registerClass("adsr", ADSR);

        globalThis.ad = register("ad", (gate = 0, attack = 0.02, decay = 0.1) =>
          adsr(gate, attack, decay, 0, decay)
        );
        /*
        impulse(1).ad(.1).mul(sine(200))
.add(x=>x.delay(.1).mul(.8))
.out()*/
        const MAX_DELAY_TIME = 10;
        class Delay extends Node {
          writeIdx = 0;
          readIdx = 0;
          buffer = new Float32Array(MAX_DELAY_TIME * sampleRate); // .fill(0)
          write(s, delayTime) {
            this.writeIdx = (this.writeIdx + 1) % this.buffer.length;
            this.buffer[this.writeIdx] = s;
            // Calculate how far in the past to read
            let numSamples = Math.min(
              Math.floor(sampleRate * delayTime),
              this.buffer.length - 1
            );
            this.readIdx = this.writeIdx - numSamples;
            // If past the start of the buffer, wrap around
            if (this.readIdx < 0) this.readIdx += this.buffer.length;
          }
          update(input, delayTime) {
            this.write(input, delayTime);
            return this.buffer[this.readIdx];
          }
        }
        globalThis.Delay = Delay;
        globalThis.delay = registerClass("delay", Delay);

        class Fold extends Node {
          update(input = 0, rate = 0) {
            if (rate < 0) rate = 0;
            rate = rate + 1;
            input = input * rate;
            return (
              4 *
              (Math.abs(0.25 * input + 0.25 - Math.round(0.25 * input + 0.25)) -
                0.25)
            );
          }
        }
        globalThis.Fold = Fold;
        globalThis.fold = registerClass("fold", Fold);

        let perc = register("perc", (gate, decay) => gate.adsr(0, 0, 1, decay));

        class Lag extends Node {
          lagUnit = 4410;
          s = 0;
          update(input, rate) {
            // Remap so the useful range is around [0, 1]
            rate = rate * this.lagUnit;
            if (rate < 1) rate = 1;
            this.s += (1 / rate) * (input - this.s);
            return this.s;
          }
        }
        globalThis.Lag = Lag;
        globalThis.lag = registerClass("lag", Lag);

        class Slew extends Node {
          last = 0;
          update(input, up, dn) {
            const upStep = up * ISR;
            const downStep = dn * ISR;
            let delta = input - this.last;
            if (delta > upStep) {
              delta = upStep;
            } else if (delta < -downStep) {
              delta = -downStep;
            }
            this.last += delta;
            return this.last;
          }
        }
        globalThis.Slew = Slew;
        globalThis.slew = registerClass("slew", Slew);

        globalThis.applyDistortion = (x, amount) => {
          amount = Math.min(Math.max(amount, 0), 1);
          amount -= 0.01;
          var k = (2 * amount) / (1 - amount);
          var y = ((1 + k) * x) / (1 + k * Math.abs(x));
          return y;
        };
        globalThis.distort = registerRaw(
          "distort",
          (r, a) => `${r} = applyDistortion(${a.join(",")})`
        );
        globalThis.hpf = register("hpf", (input, cutoff, resonance = 0) =>
          input.sub(input.lpf(cutoff, resonance))
        );

        class Sequence extends Node {
          clockSgn = true;
          step = 0;
          first = true;
          update(clock, ...ins) {
            if (!this.clockSgn && clock > 0) {
              this.step = (this.step + 1) % ins.length;
              this.clockSgn = clock > 0;
              return 0; // set first sample to zero to retrigger gates on step change...
            }
            this.clockSgn = clock > 0;
            return ins[this.step];
          }
        }
        globalThis.Sequence = Sequence;
        globalThis.seq = registerClass("seq", Sequence);
        globalThis.midinote = registerRaw(
          "midinote",
          (r, [note]) => `${r} = (2 ** ((${note} - 69) / 12) * 440)`
        );

        globalThis.midi2freq = (midi) => Math.pow(2, (midi - 69) / 12) * 440;

        globalThis.range = registerRaw(
          "range",
          (r, [bip, a, b]) => `${r} = ((${bip} + 1) / 2) * (${b} - ${a}) + ${a}`
        );
        /* let log = registerNode("log", (r, a) => `${r} = Math.log(${a})`);
        let exp = registerNode("exp", (r, a) => `${r} = Math.exp(${a})`);
        let sin = registerNode("sin", (r, a) => `${r} = Math.sin(${a})`);
        let cos = registerNode("cos", (r, a) => `${r} = Math.cos(${a})`); */

        globalThis.unipolar = registerRaw(
          "unipolar",
          (r, [bip]) => `${r} = (${bip}+1)/2;`
        );
        globalThis.bipolar = registerRaw(
          "bipolar",
          (r, [uni]) => `${r} = ${uni}*2-1;`
        );

        globalThis._rangex = (sig, min, max) => {
          let logmin = Math.log(min);
          let range = Math.log(max) - logmin;
          const unipolar = (sig + 1) / 2;
          return Math.exp(unipolar * range + logmin);
        };
        globalThis.rangex = registerRaw(
          "rangex",
          (r, args) => `${r} = _rangex(${args.join(",")})`
        );

        globalThis.pan = register("pan", (input, pos) => {
          // (pos+1)/2 * PI/2 = (pos+1) * PI * 0.25
          return input;
          /* pos = add(pos, 1).mul(Math.PI, 0.25);
          return input.mul([Math.cos(pos), Math.sin(pos)]); */
        });

        globalThis.add = registerRaw("add", (r, a) => `${r} = ${a.join("+")}`);
        globalThis.sub = registerRaw("sub", (r, a) => `${r} = ${a.join("-")}`);
        globalThis.mul = registerRaw("mul", (r, a) => `${r} = ${a.join("*")}`);
        globalThis.div = registerRaw("div", (r, a) => `${r} = ${a.join("/")}`);
        globalThis.mod = registerRaw("mod", (r, a) => `${r} = ${a.join("%")}`);
        globalThis.n = registerRaw("n", (r, x) => `${r} = ${x}`);

        Node.prototype.apply = function (x) {
          return x(this);
        };
        // sine(240).raw(([n]) => `${n}/16`)
        /* let raw = register("raw", (...args) => {
          const compileSelf = args[args.length - 1];
          return new Node("raw", args.slice(0, -1), null, compileSelf);
        }); */
        /* let raw = (type, compileSelf) =>
          register((...args) => new Node(type, args, null, compileSelf));
        let raw = registerRaw('raw', ()) */
        // sine(100).raw((arg) => `${arg}/2`)
        Object.assign(globalThis, {
          Node,
        });
      </script>
    </template>
    <script>
      function register(type, getNode = (...args) => new Node(type, args)) {
        // register method for chaining
        Node.prototype[type] = function (...args) {
          //return getNode(type, [this, ...args]);
          return getNode(this, ...args);
        };
        // return function for unchained calls
        //return (...args) => getNode(type, args);
        return getNode;
      }
      let registerFn = (type, update) =>
        //register(type, (type, args) => new Node(type, args, update));
        register(type, (...args) => new Node(type, args, { update }));

      let registerUgen = (type, name) =>
        //register(type, (type, args) => new Node(type, args, update));
        register(
          type,
          (...args) =>
            new Node(type, args, {
              compileSetup: (r) => `${r} = new ${name}()`,
            })
        );

      const registerRaw = (type, compileSelf) =>
        register(type, (...args) => {
          const argNames = Array.from(
            { length: args.length },
            (_, i) => `a${i}`
          );
          const body = `${compileSelf("let v", argNames)}; return v;`;
          const update = new Function(...argNames, body);
          return new Node(type, args, { update, compileSelf });
        });
    </script>
    <script id="node-expansion">
      let poly = registerFn("poly", (...args) => args);

      // these variables are for the stepwise viz (very dirty hack)
      let expansions = 0;
      let expansion = -1;
      let nextExpansion = 1;

      // this is the "full" version
      Node = class {
        constructor(type, ins, config) {
          this.type = type;
          this.config = config;
          const { update, compileSelf, compileSetup } = config || {};
          update && (this.update = update);
          compileSelf && (this.compileSelf = compileSelf);
          compileSetup && (this.compileSetup = compileSetup);

          // multichannel expansion
          let maxExpansions = 0;
          this.ins = ins.map((input) => {
            input = this.parseInput(input);
            if (input.type === "poly") {
              maxExpansions = Math.max(maxExpansions, input.ins.length);
            }
            return input;
          });
          if (expansion !== -1 && expansions >= expansion) {
            return; // dirty hack for viz (not needed otherwise)
          }
          if (maxExpansions > 0) {
            expansions++; // dirty hack for viz (not needed otherwise)
            this.type = "poly";
            this.update = (...args) => args;
            this.compileSelf = Node.compilePoly;
            // make mono if only one channel

            this.ins = Array(maxExpansions)
              .fill(0)
              .map((_, i) => {
                const clone = new this.constructor(type, [], config);
                clone.ins = ins.map((input) => {
                  input = clone.parseInput(input);
                  if (input.type === "poly") {
                    return input.ins[i % input.ins.length];
                  }
                  return input;
                });
                return clone;
              });
          }
        }
      };
      Node.prototype.parseInput = function (input) {
        if (typeof input === "function") {
          input = input(this); // lambda feedback
        }
        if (Array.isArray(input)) {
          input = poly(...input);
        }
        return input;
      };
      Node.prototype.input = function (node) {
        this.ins[0] = node;
        return this;
      };
    </script>
    <!-- Node.run -->
    <script id="node-run">
      Node.prototype.run = function (visited = [], results = []) {
        if (visited.includes(this)) {
          return results[this.id] ?? 0;
        }
        // run children (depth first)
        const args = this.ins.map((input) => {
          if (input instanceof Node) {
            return input.run([...visited, this], results);
          }
          return input;
        });
        // pass children results to update
        const result = this.update(...args);
        results[this.id] = result;
        return result;
      };
    </script>
    <script id="node-compile">
      Node.prototype.compile = function (memory) {
        let nodes = Array.from(topoSort(this));
        /* console.log("nodes", nodes); */
        $.n ??= [];
        const getRef = (input) =>
          typeof input !== "object" ? input : `r[${nodes.indexOf(input)}]`;
        let init = [
          `$.n ??= []; // init nodes array`,
          `const n = $.n; // only to save some chars`,
          `const r = new Float32Array(${nodes.length});`,
        ];
        let move = [];
        let create = [];
        let dsp = [`$.dsp = () => {`];

        let deps = [];
        let rootDep = dep();
        rootDep.value = -1;
        for (let id in nodes) {
          const node = nodes[id];
          if (node.compileSetup) {
            const oldId = $.n.findIndex((n) => n === node);
            if (oldId === -1) {
              create.push(`${node.compileSetup(`n[${id}]`)} // ${node.type}`);
            } else if (oldId !== Number(id)) {
              // dependency graph for variable assignments
              if (!deps[id]) {
                deps[id] = dep();
                deps[id].value = id;
              }
              if (!deps[oldId]) {
                deps[oldId] = dep();
                deps[oldId].value = oldId;
              }
              deps[oldId].ins.push(deps[id]);
              rootDep.ins.push(deps[oldId]);
              /* move.push(`n[${id}] = n[${oldId}] // ${node.type}`); */
            } else {
              // id hasn't changed -> no setup needed!
            }
          }
          const args = node.ins.map(getRef);
          const ref = getRef(node);
          let line;
          if (!node.compileSelf) {
            line = `${ref} = n[${id}].update(${args.join(",")})`;
          } else {
            line = node.compileSelf(ref, args, node, id);
          }
          line = `  ${line} // ${node.type}`;
          dsp.push(line);
        }
        dsp.push(`}`);

        // generate topo sorted variable assignments
        const assignments = Array.from(topoSort(rootDep))
          .slice(0, -1)
          .filter((dep) => dep.ins.length)
          .map((dep) =>
            dep.ins.map(
              (input) =>
                `n[${input.value}] = n[${dep.value}] // ${
                  nodes[input.value].type
                }`
            )
          );

        const last = getRef(nodes[nodes.length - 1]);
        // lines.push(`return ${last}`);

        const code = [init, assignments, create, dsp].flat().join("\n");
        console.log("-------compiled--------");
        console.log(code);
        $.n = nodes;
        return code;
      };
    </script>
    <script id="node-play">
      /* const fadein = registerUgen("fadein", "FadeIn"); */
      /* const fadeout = registerUgen("fadeout", "FadeOut"); */
      const fadein = register("fadein", (input, fadeTime) => {
        if (typeof fadeTime !== "number") {
          throw new Error("fadein: fadeTime must be a number!");
        }
        return new Node("fadein", [input, fadeTime], {
          compileSelf: (r, [input], _, id) =>
            `${r} = n[${id}].update(${input})`,
          compileSetup: (r) => `${r} = new FadeIn(${fadeTime})`,
          doneTime: ctx.currentTime + fadeTime,
        });
      });
      const fadeout = register("fadeout", (input, fadeTime) => {
        if (typeof fadeTime !== "number") {
          throw new Error("fadein: fadeTime must be a number!");
        }
        return new Node("fadeout", [input, fadeTime], {
          compileSelf: (r, [input], _, id) =>
            `${r} = n[${id}].update(${input})`,
          compileSetup: (r) => `${r} = new FadeOut(${fadeTime})`,
          doneTime: ctx.currentTime + fadeTime,
        });
      });
      const sine = registerUgen("sine", "SineOsc");
      const zaw = registerUgen("zaw", "ZawOsc");
      const saw = registerUgen("saw", "SawOsc");
      const lpf = registerUgen("lpf", "Lpf");
      const pulse = registerUgen("pulse", "PulseOsc");
      const dust = registerUgen("dust", "Dust");
      const impulse = registerUgen("impulse", "Impulse");
      const hold = registerUgen("hold", "Hold");
      const adsr = registerUgen("adsr", "ADSR");
      const delay = registerUgen("delay", "Delay");
      const fold = registerUgen("fold", "Fold");
      const lag = registerUgen("lag", "Lag");
      const slew = registerUgen("slew", "Slew");
      const seq = registerUgen("seq", "Sequence");
      const noise = registerRaw("noise", (r) => `${r} = Math.random() * 2 - 1`);

      const applyDistortion = (x, amount) => {
        amount = Math.min(Math.max(amount, 0), 1);
        amount -= 0.01;
        var k = (2 * amount) / (1 - amount);
        var y = ((1 + k) * x) / (1 + k * Math.abs(x));
        return y;
      };
      const distort = registerRaw(
        "distort",
        (r, a) => `${r} = applyDistortion(${a.join(",")})`
      );
      const hpf = register("hpf", (input, cutoff, resonance = 0) =>
        input.sub(input.lpf(cutoff, resonance))
      );

      const mix = register("mix", (input, channels = 1) => {
        if (![1, 2].includes(channels)) {
          channels = 2;
          console.warn(
            "mix only supports 1 or 2 channels atm.. falling back to 2"
          );
        }
        if (input.type !== "poly") {
          return input;
        }
        if (channels === 2) {
          const panned = input.ins.map((channel, i, ins) => {
            // we can do this at eval time: channels are fixed!
            const pos = (i / (ins.length - 1)) * 2 - 1;
            const deg = ((pos + 1) * Math.PI) / 4;
            const stereo = channel.mul([Math.cos(deg), Math.sin(deg)]);
            return stereo;
          });
          return add(...panned);
        }
        return add(...input.ins);
      });
      const ad = register("ad", (gate = 0, attack = 0.02, decay = 0.1) =>
        adsr(gate, attack, decay, 0, decay)
      );

      const range = registerRaw(
        "range",
        (r, [bip, a, b]) => `${r} = ((${bip} + 1) / 2) * (${b} - ${a}) + ${a}`
      );

      const unipolar = registerRaw(
        "unipolar",
        (r, [bip]) => `${r} = (${bip}+1)/2;`
      );
      const bipolar = registerRaw(
        "bipolar",
        (r, [uni]) => `${r} = ${uni}*2-1;`
      );

      const midi2freq = (midi) => Math.pow(2, (midi - 69) / 12) * 440;

      const _rangex = (sig, min, max) => {
        let logmin = Math.log(min);
        let range = Math.log(max) - logmin;
        const unipolar = (sig + 1) / 2;
        return Math.exp(unipolar * range + logmin);
      };
      const rangex = registerRaw(
        "rangex",
        (r, args) => `${r} = _rangex(${args.join(",")})`
      );

      const pan = register("pan", (input, pos) => {
        // (pos+1)/2 * PI/2 = (pos+1) * PI * 0.25
        return input;
        /* pos = add(pos, 1).mul(Math.PI, 0.25);
          return input.mul([Math.cos(pos), Math.sin(pos)]); */
      });

      const midinote = registerRaw(
        "midinote",
        (r, [note]) => `${r} = (2 ** ((${note} - 69) / 12) * 440)`
      );

      Node.prototype.apply = function (x) {
        return x(this);
      };

      Node.prototype.play = function () {
        // the last node must be poly to assign to $.l when compiled
        const out = this.type === "poly" ? this : n([this]);
        if (out.ins.length > 2) {
          // how about mix(2) in this case?
          console.warn("more than 2 channels! only using first 2");
        }
        out.viz();
        let code = out.compile();
        $.worklet.port.postMessage({ code });
      };
      Node.prototype.group = function (max = 1, fadeIn = 0, fadeOut = 0.1) {
        $.nodes ??= [];
        let len = $.nodes.length; // save len before messing with array (you never know)
        // fade out / retire old nodes
        $.nodes = $.nodes.reduce((acc, node, i) => {
          // assumes nodes is poly node with at least 1 channel
          const in0 = node.ins[0];
          console.log("in0", in0);
          if (in0.type === "fadeout" && ctx.currentTime > in0.config.doneTime) {
            return acc; // omit already silent node
          }
          if (in0.type === "fadein" && ctx.currentTime > in0.config.doneTime) {
            // unwrap node that's done fading in
            node.ins = node.ins.map((input) => input.ins[0]);
          }
          if (in0.type !== "fadeout" && len - i >= max) {
            if (!fadeOut) {
              return acc;
            }
            node = fadeout(node, fadeOut);
          }
          acc.push(node);
          return acc;
        }, []);

        // fade in new node
        let node = this;
        // make sure node is always poly (simplifies checks in reducer above)
        if (node.type !== "poly") {
          node = poly(node);
        }
        if (fadeIn) {
          node = fadein(node, fadeIn); // remember: node is poly
        }
        $.nodes.push(node);
        return add(...$.nodes);
      };
      Node.prototype.spawn = function (max, fadeIn, fadeOut) {
        return this.group(max, fadeIn, fadeOut).out();
      };
      Node.prototype.viz = function () {
        try {
          $.vizContainer && renderNode(this, $.vizContainer);
        } catch (err) {
          console.warn("non serializable node. probably because of feedback");
        }
        return this;
      };
    </script>
    <!-- Node.step -->
    <script>
      Node.prototype.step = function* (visited = [], results = []) {
        if (visited.includes(this)) {
          return results[this.id] ?? 0;
        }
        yield this;
        let args = [];
        let isLeaf = true;
        visited.push(this);
        for (let input of this.ins) {
          if (input instanceof Node) {
            isLeaf = false;
            yield* input.step(visited, results);
            const arg = input.run(visited, results);
            args.push(arg);
          } else {
            args.push(input);
          }
        }
        this.args = args;
        const result = this.update(...args);
        results[this.id] = result;
        if (!isLeaf) {
          yield this;
        }
        //results[this.id] = result;
      };
      //codeblock(document.currentScript, 8);
    </script>
    <script id="math-nodes">
      // register some nodes
      /* let add = registerFn("add", (a, b) => a + b);
      let sub = registerFn("sub", (a, b) => a - b);
      let mul = registerFn("mul", (a, b) => a * b);
      let div = registerFn("div", (a, b) => a / b);
      let mod = registerFn("mod", (a, b) => a % b);
      let n = registerFn("n", (a) => a); */
      let dep = registerFn("dep", (a) => a);

      let out = registerFn("out", (a) => a);
      let add = registerRaw("add", (r, a) => `${r} = ${a.join("+")}`);
      let sub = registerRaw("sub", (r, a) => `${r} = ${a.join("-")}`);
      let mul = registerRaw("mul", (r, a) => `${r} = ${a.join("*")}`);
      let div = registerRaw("div", (r, a) => `${r} = ${a.join("/")}`);
      let mod = registerRaw("mod", (r, a) => `${r} = ${a.join("%")}`);

      let n = registerRaw("n", (r, x) => `${r} = ${x}`);
    </script>
    <!-- topoSort -->
    <script>
      function isNode(node) {
        // node instanceof Node <- fails for serialized nodes (like hydro)
        return (
          typeof node === "object" &&
          Array.isArray(node.ins) &&
          typeof node.type === "string"
        );
      }
      // sort nodes by dependencies (using generator function to be able to step through)
      function* topoSort(node, visited = new Set()) {
        /* if (!(node instanceof Node) || visited.has(node)) { */
        if (!isNode(node) || visited.has(node)) {
          return; // constant values or already visited nodes
        }
        visited.add(node);
        for (let input of node.ins) {
          yield* topoSort(input, visited);
        }
        yield node;
      }
    </script>
  </head>
  <body>
    <div class="logo">
      <img src="./img/kabelsalat_logo_scrot.png" />
    </div>

    <template id="chapter0">
      <h1 class="active">1.graph based</h1>
      <h1 class="active">2.language</h1>
      <h1 class="active">3.for</h1>
      <h1 class="active">4.audio</h1>
      <h1 class="active">5.visual</h1>
      <h1 class="active">6.live coding</h1>
      <h1 class="active">7.on the web</h1>
      <h1 class="active">8.and beyond</h1>
    </template>

    <template id="chapter1">
      <h1 class="active">1.graph based</h1>
      <h1>2.language</h1>
      <h1>3.for</h1>
      <h1>4.audio</h1>
      <h1>5.visual</h1>
      <h1>6.live coding</h1>
      <h1>7.on the web</h1>
      <h1>8.and beyond</h1>
    </template>
    <template id="chapter2">
      <h1>1.graph based</h1>
      <h1 class="active">2.language</h1>
      <h1>3.for</h1>
      <h1>4.audio</h1>
      <h1>5.visual</h1>
      <h1>6.live coding</h1>
      <h1>7.on the web</h1>
      <h1>8.and beyond</h1>
    </template>
    <template id="chapter3">
      <h1>1.graph based</h1>
      <h1>2.language</h1>
      <h1 class="active">3.for</h1>
      <h1>4.audio</h1>
      <h1>5.visual</h1>
      <h1>6.live coding</h1>
      <h1>7.on the web</h1>
      <h1>8.and beyond</h1>
    </template>
    <template id="chapter4">
      <h1>1.graph based</h1>
      <h1>2.language</h1>
      <h1>3.for</h1>
      <h1 class="active">4.audio</h1>
      <h1>5.visual</h1>
      <h1>6.live coding</h1>
      <h1>7.on the web</h1>
      <h1>8.and beyond</h1>
    </template>
    <template id="chapter5">
      <h1>1.graph based</h1>
      <h1>2.language</h1>
      <h1>3.for</h1>
      <h1>4.audio</h1>
      <h1 class="active">5.visual</h1>
      <h1>6.live coding</h1>
      <h1>7.on the web</h1>
      <h1>8.and beyond</h1>
    </template>
    <template id="chapter6">
      <h1>1.graph based</h1>
      <h1>2.language</h1>
      <h1>3.for</h1>
      <h1>4.audio</h1>
      <h1>5.visual</h1>
      <h1 class="active">6.live coding</h1>
      <h1>7.on the web</h1>
      <h1>8.and beyond</h1>
    </template>
    <template id="chapter7">
      <h1>1.graph based</h1>
      <h1>2.language</h1>
      <h1>3.for</h1>
      <h1>4.audio</h1>
      <h1>5.visual</h1>
      <h1>6.live coding</h1>
      <h1 class="active">7.on the web</h1>
      <h1>8.and beyond</h1>
    </template>
    <template id="chapter8">
      <h1>1.graph based</h1>
      <h1>2.language</h1>
      <h1>3.for</h1>
      <h1>4.audio</h1>
      <h1>5.visual</h1>
      <h1>6.live coding</h1>
      <h1>7.on the web</h1>
      <h1 class="active">8.and beyond</h1>
    </template>
    <template id="hero0">
      <h2 style="font-size: 3em; z-index: 3000; position: absolute">
        kabelsalat
      </h2>
      <img
        alt="graph"
        src="https://www.businessinsider.de/wp-content/uploads/2016/02/kabelsalat.jpg"
        class="hero"
      />
    </template>
    <section>
      <clone-template tid="hero0"></clone-template>
      <clone-template tid="chapter0" class="chapters"></clone-template>
      <ul>
        <li>spoken "cable salad"</li>
        <li>paper by Felix Roos and Raphaël Forment</li>
        <li>
          <a href="https://kabel.salat.dev/" target="_blank">kabel.salat.dev</a>
        </li>
      </ul>
    </section>
    <section>
      <p>live looping:</p>
      <img src="./img/rudolf_trumpet.jpg" style="width: 800px" />
      <clone-template tid="chapter0" class="chapters"></clone-template>
      <p>
        <a href="https://www.youtube.com/watch?v=MXz8131Ut0A" target="_blank"
          >eddyflux algorave set @ rudolf5</a
        >
      </p>
    </section>
    <section>
      <p>kabelsalat + strudel</p>
      <img src="./img/ks_rudolf.png" style="width: 800px" />
      <clone-template tid="chapter0" class="chapters"></clone-template>
      <p>
        <a href="https://www.youtube.com/watch?v=MXz8131Ut0A" target="_blank"
          >eddyflux algorave set @ rudolf5</a
        >
      </p>
    </section>
    <section>
      <p>kabelsalat + orca</p>
      <img src="./img/jan_ten_solstice.png" style="width: 800px" />
      <clone-template tid="chapter0" class="chapters"></clone-template>
      <p>
        <a href="https://www.youtube.com/watch?v=1mE54z6ijhs" target="_blank"
          >jan ten @ solstice stream december</a
        >
      </p>
    </section>
    <section>
      <p>kabelsalat + midi controller</p>
      <img src="./img/ks_pulu_midi.png" style="width: 800px" />
      <clone-template tid="chapter0" class="chapters"></clone-template>
      <p>
        <a href="https://www.youtube.com/watch?v=uGn2mVF_jkI" target="_blank"
          >pulu - goa trance jam with kabelsalat</a
        >
      </p>
    </section>
    <section>
      <h2>why another live coding system?</h2>
      <!-- <clone-template tid="hero0"></clone-template> -->
      <clone-template tid="chapter0" class="chapters"></clone-template>
      <node-viz
        style="margin-top: 40px"
        code="return tidal().superdirt().supercollider()"
      ></node-viz>
      <node-viz
        style="margin-top: 40px"
        code="return strudel().superdough()['?']()"
      ></node-viz>
      <ul>
        <li>live codable dsp for strudel</li>
        <li>minimalism / resilience</li>
        <li>i want to learn</li>
        <li>inner peace</li>
        <li><strong>why not use tool X Y Z?</strong></li>
        <ul>
          <li>dynamically spawning graphs</li>
          <li>single sample feedback</li>
          <li>big codebases</li>
        </ul>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter0" class="chapters"></clone-template>
      <h2>history</h2>
      <ul>
        <li>started messing with bytebeat in late 2023</li>
        <li>
          made a wacky
          <a
            href="https://loophole-letters.netlify.app/patcher/"
            target="_blank"
            >patcher interface ui</a
          >
        </li>
        <li>
          found
          <a href="https://github.com/maximecb/noisecraft" target="_blank"
            >noisecraft</a
          >, adapted it for live coding
        </li>
        <li>kabelsalat project started on june 7, 2024</li>
        <li>also inspired by:</li>
        <ul>
          <li>SuperCollider</li>
          <li>hydra</li>
          <li>genish</li>
          <li>wax</li>
        </ul>
        <li>
          many details
          <a href="https://garten.salat.dev/" target="_blank"
            >garten.salat.dev</a
          >
        </li>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter1" class="chapters"></clone-template>
      <h2>noisecraft</h2>
      <img src="./img/nc_graph2.png" alt="graph" />
      <ul>
        <li>
          <a href="https://github.com/maximecb/noisecraft" target="_blank"
            >github.com/maximecb/noisecraft</a
          >
        </li>
        <li>project by Maxime Chevalier-Boisvert</li>
        <li>modular synth for the browser</li>
        <ul>
          <li>minimal (readable) codebase</li>
          <li>AudioWorklet only</li>
          <li>uses compilation</li>
        </ul>
        <li>kabelsalat started as a noisecraft fork without ui</li>
        <li>i gradually adapted it for live coding</li>
        <li>ended up rewriting most of it</li>
        <ul>
          <li>new compiler</li>
          <li>multichannel expansion</li>
          <li>feedback anywhere</li>
          <li>more dsp</li>
        </ul>
      </ul>
    </section>
    <script>
      globalThis.tidal = register("tidal");
      globalThis.superdirt = register("superdirt");
      globalThis.supercollider = register("supercollider");
      globalThis.strudel = register("strudel");
      globalThis.superdough = register("superdough");
      globalThis["?"] = register("?");
    </script>

    <section>
      <clone-template tid="chapter1" class="chapters"></clone-template>
      <h2>1.graph based</h2>
      <img
        src="https://blog.bela.io/images/puredata/header-2.png"
        alt="graph"
        class="hero"
      />
      <ul>
        <li>Pure Data, Max, modular synths, ...</li>
        <li>modules + cables = graph</li>
        <li>to model signal flow</li>
        <li>each module has inputs and outputs</li>
      </ul>
      <node-viz
        style="margin-top: 40px"
        code="return saw(55).lpf(200).out()"
      ></node-viz>
    </section>

    <section>
      <clone-template tid="chapter1" class="chapters"></clone-template>
      <h3>Web Audio Nodes used by strudel / superdough</h3>
      <p style="word-break: break-all">
        AnalyserNode AudioBufferSourceNode AudioDestinationNode AudioWorkletNode
        BiquadFilterNode ChannelMergerNode ChannelSplitterNode
        ConstantSourceNode ConvolverNode DelayNode DynamicsCompressorNode
        GainNode
        <span style="color: #ffffff50">IIRFilterNode</span>
        <span style="color: #ffffff50"
          >MediaElementAudioSourceNode MediaStreamAudioDestinationNode
          MediaStreamAudioSourceNode</span
        >
        OscillatorNode PannerNode StereoPannerNode WaveShaperNode
      </p>
      <ul>
        <li>❌ this is all browser only (no node.js)</li>
        <li>❌ there are differences between browsers</li>
        <li>❌ this is hard to port</li>
        <li>❌ you cannot do single sample feedback</li>
        <li>❌ it feels clunky to use</li>
      </ul>
      <pre style="font-size: 0.5em">
// a frequency modulated sine wave
const lfo = audioCtx.createOscillator();
lfo.frequency.value = 2;
let min = 200,
  max = 400;
const lfoGain = audioCtx.createGain();
lfoGain.gain.value = (max - min) / 2;
const offset = audioCtx.createConstantSource();
offset.offset.value = (max + min) / 2;
const adder = audioCtx.createGain();
lfo.connect(lfoGain).connect(adder);
offset.connect(adder);
offset.start();
const carrier = audioCtx.createOscillator();
carrier.frequency.value = 0;
adder.connect(carrier.frequency);
carrier.connect(audioCtx.destination);
carrier.start();
lfo.start();
      </pre>
    </section>
    <section>
      <clone-template tid="chapter1" class="chapters"></clone-template>
      <h3>Web Audio Nodes used by kabelsalat</h3>
      <p style="color: #ffffff50; word-break: break-all">
        AnalyserNode AudioBufferSourceNode
        <span style="color: #ffffff">AudioDestinationNode</span>
        <span style="color: #ffffff">AudioWorkletNode</span>
        BiquadFilterNode ChannelMergerNode ChannelSplitterNode
        ConstantSourceNode ConvolverNode DelayNode DynamicsCompressorNode
        GainNode IIRFilterNode MediaElementAudioSourceNode
        MediaStreamAudioDestinationNode MediaStreamAudioSourceNode
        OscillatorNode PannerNode StereoPannerNode WaveShaperNode
      </p>
      <ul>
        <li>✅ easy to run in node.js</li>
        <li>✅ no differences between browsers</li>
        <li>✅ this is easier to port</li>
        <li>✅ you can do single sample feedback</li>
        <li>✅ it feels amazing to use</li>
      </ul>
      <pre style="font-size: 0.5em">
// a frequency modulated sine wave
sine(2).range(200, 300).sine().out()
      </pre>
    </section>
    <section>
      <h2>2.language</h2>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <img src="./img/hydra_chaining.jpg" alt="hydra chaining" class="hero" />
      <!-- <p>text is...</p>
      <ul>
        <li>compact</li>
        <li>understood</li>
        <li>standardized</li>
        <li>fast</li>
      </ul> -->
    </section>
    <template id="example-node">
      <node-viz
        code="let n1 = saw(55); n1.color='cyan'; let n2 = lpf(n1, 200); n2.color='magenta'; let n3 = out(n2); n3.color = 'yellow'; return n3;"
      ></node-viz>
    </template>
    <template id="example-node-rl">
      <node-viz
        code="let n1 = saw(55); n1.color='cyan'; let n2 = lpf(n1, 200); n2.color='magenta'; let n3 = out(n2); n3.color = 'yellow'; return n3;"
        dir="RL"
      ></node-viz>
    </template>
    <template id="method-chaining">
      <p style="text-align: center">method chaining:</p>
      <pre
        class="pristine"
      ><span style="color:cyan">saw(55)</span>.<span style="color: magenta">lpf(200)</span>.<span style="color: yellow">out()</span></pre>
    </template>
    <template id="node-datastructure">
      <p style="text-align: center">Node data structure:</p>
      <pre class="pristine" style="font-size: 1em">
<span style="color:yellow">{
  "type": "out",
  "ins": [
    <span style="color:magenta" class="pristine">{
      "type": "lpf",
      "ins": [
        <span style="color:cyan" class="pristine">{
          "type": "saw",
          "ins": [55]
        }</span>
        200
      ]
    }</span>
  ]
}</span>
      </pre>
    </template>
    <template id="node-interface">
      <pre class="pristine" style="font-size: 1em">
interface Node {
  type: string;
  ins: (Node | number)[]
}</pre
      >
    </template>
    <template id="function-composition"
      ><p style="text-align: center">function composition:</p>
      <pre
        class="pristine"
      ><span style="color: yellow">out(<span style="color: magenta">lpf(<span style="color:cyan">saw(55)</span>, 200)</span>)</span></pre>
      <!-- <p style="text-align: center">lisp style:</p>
      <pre
        class="pristine"
      ><span style="color: yellow">(out <span style="color: magenta">(lpf <span style="color:cyan">(saw 55)</span> 200)</span>)</span></pre> -->
    </template>
    <template id="imperative-steps"
      ><p style="text-align: center">imperative steps:</p>
      <pre class="pristine">
<span style="color:cyan">r[0] = saw(55)</span>
<span style="color: magenta">r[1] = lpf(r[0], 200)</span>
<span style="color: yellow">out(r[1])</span>
    </pre>
    </template>
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <clone-template tid="example-node" style="width: 600px"></clone-template>
      <clone-template tid="method-chaining"></clone-template>
      <ul>
        <li>left to right reading</li>
        <li>no nesting</li>
        <li>similar to hydra / strudel</li>
        <li>this is syntax sugar for...</li>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <clone-template
        tid="example-node-rl"
        style="width: 600px"
      ></clone-template>
      <clone-template tid="function-composition"></clone-template>
      <ul>
        <li>right to left / ping pong reading</li>
        <li>nesting</li>
        <li>these nested functions generate...</li>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <clone-template
        tid="example-node-rl"
        style="width: 600px"
      ></clone-template>
      <clone-template tid="node-datastructure"></clone-template>
      <ul>
        <li>this is a like a syntax tree</li>
        <li>we can iterate over this</li>
        <li>we can do cool graph tricks</li>
        <li>we can optimize it</li>
        <li>we can compile this to...</li>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <clone-template tid="example-node" style="width: 600px"></clone-template>
      <clone-template tid="imperative-steps"></clone-template>
      <ul>
        <li>top to bottom</li>
        <li>machine friendly (low abstraction)</li>
        <li>performant</li>
        <li>language agnostic</li>
      </ul>
    </section>
    <!-- <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <clone-template tid="example-node"></clone-template>
      <clone-template tid="method-chaining"></clone-template>
      <clone-template tid="function-composition"></clone-template>
      <clone-template tid="node-datastructure"></clone-template>
      <clone-template tid="imperative-steps"></clone-template>
    </section> -->
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>chain:</p>
      <node-garden rows="3">return add(4, 2).mul(3).div(2).out()</node-garden>
    </section>
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>tree:</p>
      <node-garden rows="3">
        <!--
return add(8,2).mul( add(3,5) )
.mul( add(2,3).mul(4) ).out()
-->
      </node-garden>
    </section>
    <!-- <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>run method:</p>

      <script>
        codeblock(document.querySelector("#node-run"), 6);
      </script>
    </section> -->
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>dag:</p>
      <node-garden rows="3">
        <!--
let a = add(1, 2)
return a.mul(3).add(a).out()
          -->
      </node-garden>
      <ul>
        <li>dag = directed acyclic graph</li>
        <li>calculate nodes once and remember result</li>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>dag:</p>
      <node-garden rows="3">
        <!--
return add(1, 2)
.apply( a => a.mul(3).add(a) )
.out()
          -->
      </node-garden>
      <ul>
        <li>no variable needed</li>
        <li>no break in control flow</li>
      </ul>
    </section>

    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>multichannel:</p>
      <node-garden rows="3">
        <!--
return add([2, 3], 1).mul(4)
      -->
      </node-garden>
      <ul>
        <li>like a ziplock</li>
        <li>good for audio</li>
        <li>supercollider ripoff</li>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>channel matching:</p>
      <node-garden rows="3">
        <!--
return add([2, 3], 1).mul([4, 5])
      -->
      </node-garden>
    </section>
    <!-- <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>feedback:</p>
      <node-garden rows="3"> -->
    <!--
const node = add(1)
node.ins.push(node)
return node.out()
      -->
    <!-- </node-garden>
    </section> -->
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>feedback with lambdas:</p>
      <node-garden rows="3">
        <!--
return add(1, o=>o).out()
      -->
      </node-garden>
    </section>
    <section>
      <clone-template tid="chapter2" class="chapters"></clone-template>
      <p>multichannel expansion + feedback:</p>
      <node-garden rows="3">
        <!--
return add([2, 3], o=>o)
      -->
      </node-garden>
    </section>
    <!-- <section>
      <h2>2. for</h2>
      <pre></pre>
    </section> -->
    <section>
      <h2>3.for</h2>
      <img src="./img/horseflip.gif" class="hero" />
      <clone-template tid="chapter3" class="chapters"></clone-template>
      <p>we love repetition</p>
    </section>
    <section>
      <h2>4.audio</h2>
      <img
        src="https://manual.audacityteam.org/m/images/e/ed/mel_log_linear_spectrogram_annotated.png"
        class="hero"
      />
      <clone-template tid="chapter4" class="chapters"></clone-template>
      <ul>
        <li>run 48000 times per second</li>
        <li>make sure numbers are between -1 and 1</li>
      </ul>
    </section>
    <section>
      <p>dsp-repl:</p>
      <clone-template tid="chapter4" class="chapters"></clone-template>
      <dsp-repl rows="6"
        ><!-- 
$.dsp = (t) => {
  $.l = $.r = sin(241*t * 2*PI)/4
}
--></dsp-repl
      >
      <ul>
        <li>the $.dsp function runs for every sample = 48kHz</li>
        <li>$.l and $.r are the left and right speakers</li>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter4" class="chapters"></clone-template>
      <p>bytebeat example:</p>
      <dsp-repl rows="7"
        ><!-- 
$.dsp = (t) => {
  t = t*sampleRate;
  $.l = $.r = ((( // ryg 2011-10-10
((t*("36364689"[t>>13&7]&15))/12&128)+(((((t>>12)^(t>>12)-2)%11*t)/4|t>>13)&127)
) & 255) / 127.5 - 1)/4
}
--></dsp-repl
      >
      <ul>
        <li>only uses current time and math to make noise</li>
        <li>ackchyually this is floatbeat</li>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter4" class="chapters"></clone-template>
      <p>with kabelsalat:</p>
      <dsp-repl rows="9" viz="1"
        ><!--
register('out', (graph) => {
  graph.viz()
  graph = polify(graph).compile()
  $.dsp = () => graph.update()
})

sine(241)
.mul(sine(2).range(.5,1))
.out() // <- what we registered above
--></dsp-repl
      >
      <!-- <ul>
        <li>we're still in a bytebeat editor</li>
      </ul> -->
    </section>
    <section>
      <clone-template tid="chapter4" class="chapters"></clone-template>
      <p>multichannel:</p>
      <!-- next="1" -->
      <dsp-repl rows="6" viz="1"
        ><!--
saw([60,121,239,361]).mix(2)
.lpf(sine(.4).range(.6,.8),.2)
.mul(.6).out()
--></dsp-repl
      >
    </section>
    <section>
      <clone-template tid="chapter4" class="chapters"></clone-template>
      <p>feedback:</p>
      <!-- next="1" -->
      <dsp-repl rows="10" viz="1"
        ><!--
zaw([55,110,220,330]).lpf( sine(.25).range(.3,.7) )
.mix(2)
.mul(impulse(4).perc(.1).lag(.05))
.add(x=>x.delay(zaw(.01).range(.005,.02)).mul(.9))
.add(x=>x.delay(.3).mul(.7))
.fold().mul(.6)
.out()
--></dsp-repl
      >
    </section>
    <section>
      <clone-template tid="chapter4" class="chapters"></clone-template>
      <p>custom ugen: fm</p>
      <dsp-repl rows="24" font-size="16" viz="1"
        ><!--
let fm2 = register("fm2", (freq, fmh = 1, fmi = 4) => {
  let modfreq = n(freq).mul(fmh)
  let modgain = modfreq.mul(fmi)
  return sine(modfreq).mul(modgain).sine()
})

// rootnotes
let root = impulse(0.125).seq(40, 42, 43, 42).add(2)

$.blips ??= impulse(0.5)
  .apply((imp) =>
    imp
      .seq(0, 12, 7, 15, 3, 7)
      .add(root)
      .midinote()
      .fm2(2.005, imp.ad(0.01, 0.2).bipolar().range(2, 7))
      .mul(imp.ad(0.02, 0.4))
      .mul(imp.seq(1, 0, 1, 1, 0))
      .pan(sine(0.6))
      .add((x) => x.delay([0.33, 0.12]).mul(0.9))
  )
  .mul(0.6)

$.chords ??= n([0, 7, 10])
  .add(root)
  //.add(impulse(1).seq(0,0,7,0,12))
  .midinote()
  .mul(sine(3).range(0.96, 1.04))
  .lag(1)
  .fm2(0.501, 8)
  .mul(tri(2).range(0.5, 1))
  .mix(2)

$.bass ??= impulse(2)
  .seq(0, 0, 0, 7, 0, 12, 0, 1)
  .add(root)
  .midinote()
  .fm2(0.5, sine(2).range(6, 0.2))
  .distort(0.7)

$.kik ??= impulse(2)
  .adsr(0, 0.11, 0, 0.11)
  .apply((env) =>
    env
      .mul(env)
      .mul(158) // frequency range
      .sine(env)
      .distort(0.9)
  )

$.snare ??= impulse(2, 0.5)
  .seq(0, 1, 0, 1)
  .adsr(0, 0.1, 0.02, 0.02)
  .mul(noise())
  .lpf(0.78, 0.29)

add(
$.blips, 
$.chords, 
$.bass.mul(0), 
$.kik.mul(0), 
$.snare.mul(0)
).out()
      --></dsp-repl>
    </section>
    <section>
      <clone-template tid="chapter4" class="chapters"></clone-template>
      <p>custom ugen: chorus</p>
      <dsp-repl rows="18" viz="1" font-size="18"
        ><!--
register('chorus', (input, speed, depth = 0.5, phase=Math.random()) => {
  const maxDelay = n(depth).mul(0.005);
  let lfo = n(speed).sine(0,phase).range(0, maxDelay);
  return input.apply(x=>x.add(x.delay(lfo))).mul(.5)
})

n([0,3,7,10])
.add(impulse(1).seq(50,50,52,52,54,54,55,56))
.midinote().lag(0.69)
.saw()
.chorus([1,2.1,0.4],0.81)
.mix(2)
.lpf(0.50)
.mul(.6)
.fadein(.2)
.out()

      --></dsp-repl>
    </section>
    <section>
      <clone-template tid="chapter4" class="chapters"></clone-template>
      <p>stardust:</p>
      <!-- next="1" -->
      <dsp-repl rows="12" font-size="18" viz="1"
        ><!--
// stardust
// by pulu : https://pulusound.fi
let mel = n(sine(0.1).rangex(1, 5)).dust().apply(g => 
  g.ad(0.001,sine(11.23).rangex(0.07, 0.2)).mul(
    g.seq(52,57,60,59,45,52,59,45,57).add(g.seq(12,12,24,12,12,12)).midinote()
      .mul(g.ad(0.001,0.03).bipolar().rangex(1,noise().hold(g).rangex(0.5,2)))
      .sine()
      .mul(noise().hold(g).lag(0.001).range(0.2,1))
      .pan(noise().hold(g).lag(0.003).mul(0.8))
  )
)
  .add(x => x.delay(sine(0.121).rangex(0.333, 0.347)).mul(sine(0.54).rangex(0.3, 0.7)))
  .add(x => x.delay(sine(0.131).rangex(0.543, 0.557)).mul(sine(0.64).rangex(0.3, 0.7)))
  .mul(1.05);
let wind = noise()
  .mul(dust(18).ad(0.003,0.05).bipolar().rangex(0.6,1))
  .add(noise().hold(dust(500)))
  .mul(n(0.7).apply(r => noise().hold(impulse(r)).slew(r).rangex(0.4,1)))
  .distort(0.5)
  .lpf(n(0.2).apply(r => noise().hold(impulse(r)).slew(r).rangex(0.5,0.9)),0.2)
  .hpf(n(0.33).apply(r => noise().hold(impulse(r)).slew(r).rangex(0.3,0.4)))
  .pan(sine(0.12).mul(0.7))
  .add(x => x.delay(0.65).mul(0.72))
  .mul(0.2);
let drone = add(...[0,7,10,12].map((x,i) =>
  n(x+45).midinote().sine()
    .mul(n(x/25).sine(0, i/2*Math.PI).unipolar())
    .pan(sine(1, 0, i/2*Math.PI).mul(0.6))
))
  .mul(0.8);
add(mel, wind, drone)
//.spawn(1,4,4)
.out()
--></dsp-repl
      >
    </section>
    <section>
      <h2>5.visual</h2>
      <img
        src="./img/mechanicalgif2.gif"
        class="hero"
        style="height: 600px; width: 600px"
      />
      <clone-template tid="chapter5" class="chapters"></clone-template>
      <ul>
        <li>graphs are also useful for visuals</li>
        <li>poc: hydro = kabelsalat + hydra</li>
        <li>compiles kabelsalat Node's to glsl code</li>
        <li>
          <a href="https://codeberg.org/froos/hydro" target="_blank"
            >codeberg.org/froos/hydro</a
          >
        </li>
      </ul>
    </section>
    <section>
      <clone-template tid="chapter5" class="chapters"></clone-template>

      <iframe
        id="hydroFrame"
        src="hydro.html"
        style="border: 0; width: 800px; height: 500px"
      ></iframe>
      <textarea
        spellcheck="false"
        id="hydroInput"
        rows="6"
        style="font-size: 0.6em"
      ></textarea>
      <div id="hydroViz" style="height: 800px"></div>
      <script>
        hydroInput.value = `// 3.3 by ΔNDR0M3DΔ, CC BY-NC-SA 4.0
osc().modulateRotate(o0,0.3).out()
osc(33,0.3,0.3).diff(o3,3).out(o1)
osc(3,0.3,33).modulateKaleid(o3,3).diff(o0).out(o2)
src(o0,3).mult(o1,3).kaleid(3).out(o3)
render(o2)`;
        let hydroMsg = (msg) => hydroFrame.contentWindow.postMessage(msg);
        let updateHydro = (code) => hydroMsg({ code });
        let stopHydro = (code) => hydroMsg({ stop: true });
        const typeFunctions = {
          vec2: [
            "st",
            "rotate",
            "scale",
            "pixelate",
            "repeat",
            "repeatX",
            "repeatY",
            "kaleid",
            "scroll",
            "scrollX",
            "scrollY",
            "modulateRepeat",
            "modulateRepeatX",
            "modulateRepeatY",
            "modulateKaleid",
            "modulateScrollX",
            "modulateScrollY",
            "modulate",
            "modulateScale",
            "modulatePixelate",
            "modulateRotate",
            "modulateHue",
          ],
          vec4: [
            "noise",
            "voronoi",
            "osc",
            "shape",
            "gradient",
            "src",
            "solid",
            "prev",
            "posterize",
            "shift",
            "invert",
            "contrast",
            "brightness",
            "luma",
            "thresh",
            "color",
            "saturate",
            "hue",
            "colorama",
            "sum",
            "r",
            "g",
            "b",
            "a",
            "add",
            "sub",
            "layer",
            "blend",
            "mult",
            "diff",
            "mask",
            "out",
            "render",
          ],
        };
        const typeColor = {
          vec2: "cyan",
          vec4: "magenta",
        };
        function getType(functionName) {
          if (functionName.startsWith("_")) {
            functionName = functionName.slice(1);
          }
          const match = Object.entries(typeFunctions).find(([key, fns]) =>
            fns.includes(functionName)
          );
          return match?.[0];
        }
        function getFunctionColor(functionName) {
          const type = getType(functionName);
          if (type) {
            return typeColor[type];
          }
          return "white";
        }
        window.hydroOut = (outputs) => {
          const output = {
            type: "render",
            ins: Object.values(outputs).map((output, i) => ({
              type: "out",
              ins: [output, i],
            })),
          };
          renderNode(
            output,
            hydroViz,
            (gvnode, node) => {
              gvnode.color = getFunctionColor(node.type);
              return gvnode;
            },
            (gvedge, target, i) => {
              gvedge.color = getFunctionColor(target.ins[i].type);
              return gvedge;
            },
            "TB"
          );
        };

        let maybeRender = () => {
          const slide = getSlide();
          if (slide.contains(hydroFrame)) {
            updateHydro(hydroInput.value);
          } else {
            stopHydro();
          }
        };
        /* maybeRender(); */
        document.addEventListener("change-slide", () => maybeRender());
        hydroInput.addEventListener("keydown", (e) => {
          if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
            updateHydro(e.target.value);
          }
          if ((e.ctrlKey || e.altKey) && e.code === "Period") {
            stopHydro();
          }
        });
        /* hydroMsg({ code: hydroInput.value }); */
      </script>
    </section>
    <section>
      <img src="./img/itsallgraphs.png" />
      <clone-template tid="chapter5" class="chapters"></clone-template>
    </section>
    <section>
      <h2>6.live coding</h2>
      <clone-template tid="chapter6" class="chapters"></clone-template>
    </section>
    <section>
      <clone-template tid="chapter6" class="chapters"></clone-template>
      <p>spawn:</p>
      <dsp-repl rows="6" viz="1"
        ><!--
$.m ??= 0
$.m = ($.m+5)%24+50

midinote($.m).sine().spawn(2, 1, 1)
--></dsp-repl
      >
    </section>
    <section>
      <clone-template tid="chapter6" class="chapters"></clone-template>
      <p>fx spawn:</p>
      <!-- next="1" -->
      <dsp-repl rows="10" viz="1"
        ><!--
$.m ??= 0
$.m = ($.m+5)%24+50
$.fx ??= add(0,x=>x.delay(.2).mul(.8))
$.lfo ??= sine(.5)

add($.m,0)
.midinote().saw().mul(impulse(0).ad(.02,.3))
.lpf($.lfo.range(.4,.8),.3)
//.mul([1,0.5])
//.group(2, 0, 0)
.send($.fx)
.mul(.5)
.out()
--></dsp-repl
      >
    </section>
    <section>
      <clone-template tid="chapter6" class="chapters"></clone-template>
      <p>dynamic spawn:</p>
      <!-- next="1" -->
      <dsp-repl rows="10" viz="1"
        ><!--
    $.m ??= 0
$.m = ($.m+5)%12

let env = impulse(0).ad(.02,.4)
n($.m+52).add([0,3,7,10,14]).midinote()
.pulse(.2).mix(2)
.lpf(env,.3).div(4)
.mul(env)
.add(x=>x.delay(.16).mul(.5))
.spawn(2, 0, .1)
--></dsp-repl
      >
    </section>
    <script>
      const slides = Array.from(document.querySelectorAll("section"));
      let slideIndex = Number(window.location.hash.slice(1)) || 0;
      function getSlide() {
        return slides[slideIndex];
      }
      let setSlideIndex = (index) => {
        slideIndex = index % slides.length;
        document.dispatchEvent(
          new CustomEvent("change-slide", {
            detail: slideIndex,
          })
        );
        slides.forEach((slide, i) => {
          //slide.style.display = "none";
          if (i < slideIndex) {
            /* slide.style.transform = "translate(-100vw)"; */
            slide.style.opacity = "0";
            slide.style.pointerEvents = "none";
          } else if (i === slideIndex) {
            /* slide.style.transform = "translate(0px,0px)"; */
            slide.style.opacity = "1";
            //slide.style.display = "flex";
            slide.style.pointerEvents = "inherit";
          } else if (i > slideIndex) {
            /* slide.style.transform = "translate(100vw)"; */
            slide.style.opacity = "0";
            slide.style.pointerEvents = "none";
          }
          // slide.style.display = "none";
        });
        const slide = slides[slideIndex];
        // slide.style.display = "flex";
        window.location.hash = slideIndex;
      };
      setSlideIndex(slideIndex);
      let nextSlide = () => setSlideIndex((slideIndex + 1) % slides.length);
      let prevSlide = () =>
        setSlideIndex((slideIndex - 1 + slides.length) % slides.length);
      window.nextSlide = nextSlide;
      window.prevSlide = prevSlide;
      document.onkeydown = (e) => {
        if (e.ctrlKey) {
          if (e.key === "ArrowLeft") {
            prevSlide();
          } else if (e.key === "ArrowRight") {
            nextSlide();
          }
        }
      };
    </script>
  </body>
</html>
