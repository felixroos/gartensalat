<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>ðŸŒ± fakeshader</title>
    <style>
      body {
        margin: 0;
        background: black;
      }
      canvas {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="500" height="500"></canvas>
    <script>
      class FakeShader {
        constructor(canvas) {
          this.o = { r: 0, g: 0, b: 0 };
          this.i = { t: 0, x: 0, y: 0, px: 0, py: 0, i: 0 };
          this.g = { dim: 64, sharp: true }; // global object
          this.ctx = canvas.getContext("2d");
          const rect = canvas.getBoundingClientRect();
          canvas.width = rect.width; // * window.devicePixelRatio;
          canvas.height = rect.height; // * window.devicePixelRatio;
        }
        update(code) {
          const main = new Function("g", `${code}\n return main;`)(this.g);
          if (this.lastDim !== this.g.dim) {
            this.imageData = this.ctx.createImageData(this.g.dim, this.g.dim);
            this.lastDim = this.g.dim;
          }
          let frame = () => {
            const { i, g, imageData, ctx } = this;
            this.i.t = performance.now() / 1000;
            this.draw(main);
            this.raf = requestAnimationFrame(frame);
          };
          this.raf && cancelAnimationFrame(this.raf);
          frame();
        }
        draw(main) {
          const { imageData, ctx, i, o, g } = this;
          const dim = g.dim;
          const blocks = dim * dim; // total blocks
          for (let block = 0; block < blocks; block++) {
            // calculate normalized coordinates
            i.px = block % dim;
            i.x = (i.px + 0.5) / dim;
            i.py = dim - Math.floor(block / dim) - 1;
            i.y = (i.py + 0.5) / dim;
            i.i = block;
            o.r = o.g = o.b = 0;
            main(i, o); // changes contents of o
            let blockStart = block * 4; // 4 per block = rgba
            imageData.data[blockStart] = o.r * 255;
            imageData.data[blockStart + 1] = o.g * 255;
            imageData.data[blockStart + 2] = o.b * 255;
            imageData.data[blockStart + 3] = 255;
          }
          ctx.putImageData(imageData, 0, 0);
          ctx.imageSmoothingEnabled = !g.sharp; // this needs to be here for some reason
          const { width, height } = ctx.canvas;
          ctx.drawImage(ctx.canvas, 0, 0, dim, dim, 0, 0, width, height); // scale up
        }
      }
      console.log(
        `welcome to fakeshader.
available functions: 
- $: run full fakeshader code, expected to define a main function
- $$: run expression using x,y,t. expected to set any of o.r, o.g, o.b
examples: 
- $\`let main = ({t,i,x,y,px,py},o)=>o.r=o.b=(y**x*(120+t))%1\`
- $$\`o.r=o.g=(y**x*(120+t))%1\`
more info: https://garten.salat.dev/fake-shaders2.html`
      );
      const canvas = document.querySelector("#canvas");
      const shader = new FakeShader(canvas);
      // live coding / sharing logic
      window.addEventListener("hashchange", function () {
        const urlCode = atob(window.location.hash.slice(1));
        shader.update(urlCode);
      });
      let urlCode = window.location.hash.slice(1);
      if (urlCode) {
        console.log("loaded code from url:");
        urlCode = atob(urlCode);
        console.log(`$\`${urlCode}\``);
      }
      const defaultCode = "let main=({t,i,x,y},o)=>o.g=o.b=(y**x*(120+t))%1";
      const initialCode = urlCode || defaultCode;
      shader.update(initialCode);
      window.$ = (code) => {
        window.location.hash = "#" + btoa(code + "");
      };
      window.$$ = (code) => $(`let main = ({t,i,x,y,px,py},o) => ${code}`);
      window.$$$ = (code) =>
        $(`let main = ({t,i,x,y,px,py},o) => o.r=o.g=o.b=${code}`);
      window.tixyland = (code) =>
        $(`g.dim=16;let main = ({t,i,x,y,px,py},o) => {
        x=px; y=15-py;
        let c = ${code};
        if(c>=0) {
          o.r=o.g=o.b=c;
        } else {
          o.r=c*-1;
        }}`);
    </script>
  </body>
</html>
