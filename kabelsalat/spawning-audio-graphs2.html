<!DOCTYPE html>
<html>
  <!-- license: AGPL-3.0 -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ðŸŒ± spawning audio graphs II</title>
    <style>
      body {
        background-color: #222;
        max-width: 500px;
        margin: auto;
        font-family: serif;
        font-size: 1.2em;
        color: #edd;
        padding: 20px 8px;
      }
      @font-face {
        font-family: "FontWithASyntaxHighlighter";
        src: url("/fonts/FontWithASyntaxHighlighter-Regular.woff2")
          format("woff2");
      }
      a {
        color: cyan;
        font-size: 1em;
      }
      textarea,
      pre {
        box-sizing: border-box;
        font-family: "FontWithASyntaxHighlighter", monospace;
        padding: 8px;
        font-size: 12px;
        border: 0;
        outline: none;
        overflow: auto;
        background-color: #44444490;
        color: white;
        width: 100%;
        margin-top: 8px;
        box-sizing: border-box;
      }
      #lines {
        height: 200px;
      }
    </style>
    <!-- codeblock -->
    <script>
      // render codeblock from script tag
      let codeblock = (scriptElement, indent = 0) => {
        const script = document.currentScript;
        const pre = document.createElement("pre");
        pre.textContent = getCode(scriptElement, indent);
        script.after(pre);
      };
      function getCode(scriptElement, indent = 0) {
        return scriptElement.innerText
          .split("\n")
          .map((line) => line.slice(indent))
          .filter((x) => x && !x.startsWith("codeblock("))
          .join("\n");
      }
    </script>
    <template class="dsp-worklet">
      <script>
        class DspProcessor extends AudioWorkletProcessor {
          dsp = () => {};
          l = 0;
          r = 0;
          SR = sampleRate;
          ISR = 1 / sampleRate;
          constructor() {
            super();
            this.t = 0;
            this.S = 0;
            this.active = true;
            this.framebuffer = new Float32Array(Math.floor(sampleRate / 30));

            this.msg = {
              framebuffer: this.framebuffer,
            };
            globalThis.$ = this;
            this.port.onmessage = (e) => {
              const msg = e.data;
              if (msg && msg.code) {
                //new Function("$", msg.code)(this);
                new Function(msg.code)();
              } else if (msg === "stop") {
                this.active = false;
              }
            };
          }
          process(inputs, outputs, parameters) {
            const output = outputs[0];
            for (let i = 0; i < output[0].length; i++) {
              this.dsp(this.t / sampleRate);
              output[0][i] = this.l;
              output[1][i] = this.r;
              this.t++;
              this.S = this.t * this.ISR;
              this.framebuffer[this.t % this.framebuffer.length] = this.l;
              if (this.t % this.framebuffer.length === 0 && this.t > 0) {
                this.port.postMessage(this.msg);
              }
            }
            return this.active;
          }
        }
      </script>
    </template>
    <!-- dsp-repl -->
    <script>
      const ctx = new AudioContext();
      // init audio context
      document.addEventListener("click", function firstClick() {
        ctx.resume(); // autoply policy
        document.removeEventListener("click", firstClick);
      });

      const _lerp = (v, min, max) => v * (max - min) + min;
      const invLerp = (v, min, max) => (v - min) / (max - min);
      const remap = (v, vmin, vmax, omin, omax) =>
        _lerp(invLerp(v, vmin, vmax), omin, omax);

      class DSPRepl extends HTMLElement {
        static observedAttributes = ["code", "rows"];
        worklet;
        init() {
          const code =
            this.getAttribute("code") ||
            (this.innerHTML + "").replace("<!--", "").replace("-->", "").trim();

          const rows = this.getAttribute("rows") ?? 4;
          if (!code) {
            return;
          }
          this.innerHTML = "";
          this.insertAdjacentHTML(
            "beforeend",
            `<div style="border:2px solid #222;padding:0;">
            <textarea id="code" spellcheck="false" rows="${rows}"></textarea>
            <div style="user-select:none;cursor:pointer">
            <a class="play">run</a> | <a class="stop">stop</a>
            </div>
            <canvas width="250" height="60"></canvas>
            <div class="viz" style="display:none;justify-content:center;padding:10px;height:200px"></div>
            </div>
            `
            //
          );
          // draw logic
          this.vizContainer = this.querySelector(".viz");
          this.canvas = this.querySelector("canvas");
          this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;
          this.canvas.height =
            this.canvas.clientHeight * window.devicePixelRatio;
          this.drawContext = this.canvas.getContext("2d");
          this.drawSilence(this.drawContext);

          // repl logic
          const input = this.querySelector("textarea");
          input.value = code;
          input.style = "margin:0;border-bottom:2px solid #222";
          this.input = input;

          this.querySelector(".play").onclick = () => this.update(input.value);
          this.querySelector(".stop").onclick = () => this.stop();
          input.addEventListener("keydown", async (e) => {
            if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
              const hash = btoa(input.value);
              let urlCode = window.location.hash.slice(1);
              this.update(input.value);
            }
            if ((e.ctrlKey || e.altKey) && e.code === "Period") {
              e.preventDefault();
              this.stop();
            }
          });
        }
        async initWorklet() {
          if (this.worklet) {
            return;
          }
          await ctx.resume();
          this.worklet = await this.runWorklet(ctx, this.input.value);
          /* this.worklet.port.onmessage = (e) =>
            requestAnimationFrame(() => this.drawBuffer(e.data)); */
          this.worklet.port.onmessage = (e) => {
            if (e.data.framebuffer) {
              requestAnimationFrame(() => this.drawBuffer(e.data.framebuffer));
            } else if (e.data.viz) {
              renderNodes(e.data.viz, this.vizContainer);
              this.vizContainer.style.display = "flex";
            }
          };
        }

        async update(code) {
          await this.initWorklet();
          this.worklet.port.postMessage({ code });
        }
        stop() {
          this.worklet?.disconnect();
          this.worklet?.port.postMessage("stop");
          this.worklet = undefined;
        }

        async runWorklet(ac) {
          const name = `worklet-${Date.now()}`;
          const math = Object.getOwnPropertyNames(Math).join(",");
          let prelude = `const {${math}} = Math;\nObject.assign(globalThis,{${math}})\n`;
          // add dsp scripts
          document
            .querySelector("template.dsp-prelude")
            .content.querySelectorAll("script")
            .forEach((script) => {
              prelude += script.textContent;
            });

          let workletCode = document
            .querySelector("template.dsp-worklet")
            .content.querySelector("script").textContent;

          workletCode = `${prelude}\n${workletCode}\nregisterProcessor('${name}', DspProcessor);`;

          await ac.resume();
          const dataURL = `data:text/javascript;base64,${btoa(workletCode)}`;
          await ac.audioWorklet.addModule(dataURL);
          const node = new AudioWorkletNode(ac, name, {
            outputChannelCount: [2],
          });
          node.connect(ac.destination);
          return node;
        }

        drawBuffer(samples) {
          const ctx = this.drawContext;
          const canvas = ctx.canvas;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.lineWidth = 2;
          ctx.strokeStyle = "white";
          let x0 = 1;
          let x1 = samples.length;
          let y0 = -1;
          let y1 = 1;
          let px0 = 0;
          let px1 = ctx.canvas.width;
          let py0 = ctx.canvas.height - ctx.lineWidth;
          let py1 = ctx.lineWidth;
          ctx.beginPath();
          for (let px = 0; px < ctx.canvas.width; px++) {
            const x = remap(px, px0, px1, x0, x1);
            const y = samples[Math.floor(x)];
            const py = remap(y, y0, y1, py0, py1);
            px === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
          }
          ctx.stroke();
        }

        drawSilence(ctx, color = "white", lineWidth = 2) {
          const canvas = ctx.canvas;
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height / 2);
          ctx.lineTo(canvas.width, canvas.height / 2);
          ctx.stroke();
        }

        connectedCallback() {
          setTimeout(() => {
            this.init();
          }, 0);
        }
        attributeChangedCallback(name, oldValue, newValue) {
          this.init();
        }
      }
      customElements.define("dsp-repl", DSPRepl);
    </script>
    <template class="dsp-prelude">
      <!-- Node -->
      <script>
        // https://garten.salat.dev/kabelsalat/graph-computation.html
        class Node {
          constructor(type, ins, update, compileSelf) {
            this.type = type;
            update && (this.update = update);
            compileSelf && (this.compileSelf = compileSelf);

            // multichannel expansion
            let maxExpansions = 0;
            this.ins = ins.map((input) => {
              input = this.parseInput(input);
              if (input.type === "poly") {
                maxExpansions = Math.max(maxExpansions, input.ins.length);
              }
              return input;
            });
            if (maxExpansions > 0) {
              this.type = "poly";
              this.update = (...args) => args;
              this.compileSelf = (r, args) =>
                `$.l=${args[0]}*0.3;$.r=${args[1] || args[0]}*0.3;`;
              // make mono if only one channel

              this.ins = Array(maxExpansions)
                .fill(0)
                .map((_, i) => {
                  const clone = new this.constructor(
                    type,
                    [],
                    update,
                    compileSelf
                  );
                  clone.ins = ins.map((input) => {
                    input = clone.parseInput(input);
                    if (input.type === "poly") {
                      return input.ins[i % input.ins.length];
                    }
                    return input;
                  });
                  return clone;
                });
            }
          }
          run() {
            const args = this.ins.map((input) => {
              if (input instanceof Node) {
                return input.run();
              }
              return input;
            });
            return this.update(...args);
          }
        }
      </script>
      <script id="parse-input">
        Node.prototype.parseInput = function (input) {
          if (typeof input === "function") {
            input = input(this); // lambda feedback
          }
          // multichannel expansion
          if (Array.isArray(input)) {
            input = poly(...input);
          }
          return input;
        };
      </script>
      <script>
        Node.prototype.compile = function (memory) {
          let nodes = Array.from(topoSort(this));
          // console.log(memory.join("\n"));
          let r = memory ? memory : Array(nodes.length).fill(0);
          const getRef = (input) =>
            typeof input !== "object" ? input : `r[${nodes.indexOf(input)}]`;
          let lines = [];
          for (let id in nodes) {
            const node = nodes[id];
            const args = node.ins.map(getRef);
            const ref = getRef(node);
            if (!node.compileSelf) {
              lines.push(`${ref} = n[${id}].update(${args.join(",")})`);
            } else {
              lines.push(node.compileSelf(ref, args, node, id));
            }
            lines[lines.length - 1] += ` // ${node.type}`;
          }
          const last = getRef(nodes[nodes.length - 1]);
          // lines.push(`return ${last}`);
          const code = lines.join("\n");
          console.log("-------compiled--------");
          console.log(code);
          const update = new Function("n", "r", code);
          return new Node("compiled", [], () => update(nodes, r));
        };
        Node.prototype.viz = function () {
          try {
            const nodes = Array.from(topoSort(this));
            let flat = nodes.map((node, id) => ({
              id,
              type: node.type,
              ins: node.ins.map((input) =>
                input instanceof Node ? String(nodes.indexOf(input)) : input
              ),
            }));
            $.port.postMessage({ viz: flat });
          } catch (err) {
            console.log("err", err);
            console.warn("non serializable node. probably because of feedback");
          }
          return this;
        };

        const register = (type, getNode) => {
          Node.prototype[type] = function (...args) {
            return getNode(this, ...args);
          };
          return getNode;
        };
        const registerFn = (type, update) =>
          register(type, (...args) => new Node(type, args, update));

        const registerClass = (type, NodeClass) =>
          register(type, (...args) => new NodeClass(type, args));

        const registerRaw = (type, compileSelf) =>
          register(type, (...args) => {
            const argNames = Array.from(
              { length: args.length },
              (_, i) => `a${i}`
            );
            const body = `${compileSelf("let v", argNames)}; return v;`;
            const update = new Function(...argNames, body);
            return new Node(type, args, update, compileSelf);
          });
        const poly = registerFn("poly", (...args) => args);
      </script>
      <!-- topoSort -->
      <script>
        // https://garten.salat.dev/kabelsalat/graph-compilation.html
        // sort nodes by dependencies (using generator function to be able to step through)
        function* topoSort(node, visited = new Set()) {
          if (!(node instanceof Node) || visited.has(node)) {
            return; // constant values or already visited nodes
          }
          visited.add(node);
          for (let input of node.ins) {
            yield* topoSort(input, visited);
          }
          yield node;
        }
      </script>

      <script id="play-method">
        Node.prototype.play = function () {
          // the last node must be poly to assign to $.l when compiled
          const out = this.type === "poly" ? this : n([this]);
          if (out.ins.length > 2) {
            console.warn("more than 2 channels! only using first 2");
          }
          let compiled = out.compile();
          out.viz(); // only works after .compile
          $.dsp = () => compiled.run();
          return compiled;
        };
        Node.prototype.out = Node.prototype.play;
      </script>
      <script id="collect-method">
        Node.prototype.collect = function (max = 1) {
          $.nodes ??= [];
          $.nodes.push(this);
          $.nodes = $.nodes.slice(-max);
          return add(...$.nodes);
        };
      </script>
      <script id="group-method">
        Node.prototype.group = function (max = 1, fadeIn = 0, fadeOut = 0.1) {
          $.nodes ??= [];
          let len = $.nodes.length;
          // fade out / retire old nodes
          $.nodes = $.nodes.reduce((acc, node, i) => {
            // assumes nodes is poly node with at least 1 channel
            const in0 = node.ins[0];
            //console.log("in0", in0);
            if (in0.type === "fadeout" && in0.done) {
              return acc; // omit already silent node
            }
            if (in0.type === "fadein" && in0.done) {
              node.ins = node.ins.map((input) => input.ins[0]);
            }
            if (in0.type !== "fadeout" && len - i >= max) {
              if (!fadeOut) {
                return acc;
              }
              node = fadeout(node, fadeOut);
            }
            acc.push(node);
            return acc;
          }, []);

          // fade in new node
          let node = fadeIn ? this.fadein(fadeIn) : this;
          // make sure node is always poly (simplifies checks in reducer above)
          if (node.type !== "poly") {
            node = poly(node);
          }
          $.nodes.push(node);
          return add(...$.nodes);
        };
        Node.prototype.spawn = function (max = 1, fadeIn = 1, fadeOut = 1) {
          return this.group(max, fadeIn, fadeOut).play();
        };
      </script>
      <script id="fade">
        // maybe these could be combined into a single Node
        class FadeIn extends Node {
          start = $.S;
          done = false;
          update(input, fadeTime = 1) {
            const progress = ($.S - this.start) / fadeTime;
            if (progress >= 1) {
              this.done = true;
              return input;
            }
            const gain = Math.min(1, progress);
            return input * gain;
          }
        }
        globalThis.FadeIn = FadeIn;
        globalThis.fadein = registerClass("fadein", FadeIn);
        class FadeOut extends Node {
          start = $.S;
          done = false;
          update(input, fadeTime = 1) {
            this.init = true;
            const progress = ($.S - this.start) / fadeTime;
            if (progress >= 1) {
              this.done = true;
              return 0;
            }
            const gain = 1 - Math.min(1, progress);
            return input * gain;
          }
        }
        globalThis.FadeOut = FadeOut;
        globalThis.fadeout = registerClass("fadeout", FadeOut);
      </script>

      <script>
        const ISR = 1 / sampleRate;
        // https://garten.salat.dev/audio-dsp/oscillators.html
        class SineOsc extends Node {
          phase = 0;
          update(freq) {
            const value = Math.sin(this.phase * 2 * Math.PI);
            this.phase = (this.phase + freq / sampleRate) % 1;
            return value;
          }
        }
        globalThis.SineOsc = SineOsc;
        globalThis.sine = registerClass("sine", SineOsc);

        class ZawOsc extends Node {
          phase = 0;
          update(freq) {
            this.phase += ISR * freq;
            return (this.phase % 1) * 2 - 1;
          }
        }
        globalThis.ZawOsc = ZawOsc;
        globalThis.zaw = registerClass("zaw", ZawOsc);

        function polyBlep(t, dt) {
          // 0 <= t < 1
          if (t < dt) {
            t /= dt;
            // 2 * (t - t^2/2 - 0.5)
            return t + t - t * t - 1;
          }
          // -1 < t < 0
          if (t > 1 - dt) {
            t = (t - 1) / dt;
            // 2 * (t^2/2 + t + 0.5)
            return t * t + t + t + 1;
          }
          // 0 otherwise
          return 0;
        }
        class SawOsc extends Node {
          //phase = Math.random();
          phase = 0;
          update(freq) {
            const dt = freq / sampleRate;
            let p = polyBlep(this.phase, dt);
            let s = 2 * this.phase - 1 - p;
            this.phase += dt;
            if (this.phase > 1) {
              this.phase -= 1;
            }
            return s;
          }
        }
        globalThis.SawOsc = SawOsc;
        globalThis.saw = registerClass("saw", SawOsc);

        globalThis.mix = register("mix", (input, channels = 1) => {
          if (![1, 2].includes(channels)) {
            channels = 2;
            console.warn(
              "mix only supports 1 or 2 channels atm.. falling back to 2"
            );
          }
          if (input.type !== "poly") {
            return input;
          }
          if (channels === 2) {
            const panned = input.ins.map((channel, i, ins) => {
              // we can do this at eval time: channels are fixed!
              const pos = (i / (ins.length - 1)) * 2 - 1;
              const deg = ((pos + 1) * Math.PI) / 4;
              const stereo = channel.mul([Math.cos(deg), Math.sin(deg)]);
              return stereo;
            });
            return add(...panned);
          }
          return add(...input.ins);
        });

        class Lpf extends Node {
          s0 = 0;
          s1 = 0;
          update(s, cutoff, resonance = 0) {
            // Out of bound values can produce NaNs
            cutoff = Math.min(cutoff, 1);
            resonance = Math.max(resonance, 0);
            var c = Math.pow(0.5, (1 - cutoff) / 0.125);
            var r = Math.pow(0.5, (resonance + 0.125) / 0.125);
            var mrc = 1 - r * c;
            var v0 = this.s0;
            var v1 = this.s1;
            // Apply the filter to the sample
            v0 = mrc * v0 - c * v1 + c * s;
            v1 = mrc * v1 + c * v0;
            s = v1;
            this.s0 = v0;
            this.s1 = v1;
            return s;
          }
        }
        globalThis.Lpf = Lpf;
        globalThis.lpf = registerClass("lpf", Lpf);

        class PulseOsc extends Node {
          phase = 0;
          update(freq, duty = 0.5) {
            this.phase += ISR * freq;
            let cyclePos = this.phase % 1;
            return cyclePos < duty ? 1 : -1;
          }
        }
        globalThis.PulseOsc = PulseOsc;
        globalThis.pulse = registerClass("pulse", PulseOsc);

        class Dust extends Node {
          update = (density) =>
            Math.random() < density * ISR ? Math.random() : 0;
        }
        globalThis.Dust = Dust;
        globalThis.dust = registerClass("dust", Dust);

        class Impulse extends Node {
          phase = 1;
          update(freq) {
            this.phase += ISR * freq;
            let v = this.phase >= 1 ? 1 : 0;
            this.phase = this.phase % 1;
            return v;
          }
        }
        globalThis.Impulse = Impulse;
        globalThis.impulse = registerClass("impulse", Impulse);

        globalThis.noise = registerRaw(
          "noise",
          (r) => `${r} = Math.random() * 2 - 1`
        );

        class Hold extends Node {
          value = 0;
          trigSgn = false;
          update(input, trig) {
            if (!this.trigSgn && trig > 0) this.value = input;
            this.trigSgn = trig > 0;
            return this.value;
          }
        }
        globalThis.Hold = Hold;
        globalThis.hold = registerClass("hold", Hold);

        function lerp(x, y0, y1) {
          if (x >= 1) return y1;

          return y0 + x * (y1 - y0);
        }

        class ADSR extends Node {
          state = "off";
          startTime = 0;
          startVal = 0;

          update(gate, attack, decay, susVal, release) {
            let curTime = $.S; // $.S = time in seconds
            switch (this.state) {
              case "off": {
                if (gate > 0) {
                  this.state = "attack";
                  this.startTime = curTime;
                  this.startVal = 0;
                }
                return 0;
              }
              case "attack": {
                let time = curTime - this.startTime;
                if (time > attack) {
                  this.state = "decay";
                  this.startTime = curTime;
                  return 1;
                }
                return lerp(time / attack, this.startVal, 1);
              }
              case "decay": {
                let time = curTime - this.startTime;
                let curVal = lerp(time / decay, 1, susVal);
                if (gate <= 0) {
                  this.state = "release";
                  this.startTime = curTime;
                  this.startVal = curVal;
                  return curVal;
                }
                if (time > decay) {
                  this.state = "sustain";
                  this.startTime = curTime;
                  return susVal;
                }
                return curVal;
              }
              case "sustain": {
                if (gate <= 0) {
                  this.state = "release";
                  this.startTime = curTime;
                  this.startVal = susVal;
                }
                return susVal;
              }
              case "release": {
                let time = curTime - this.startTime;
                if (time > release) {
                  this.state = "off";
                  return 0;
                }
                let curVal = lerp(time / release, this.startVal, 0);
                if (gate > 0) {
                  this.state = "attack";
                  this.startTime = curTime;
                  this.startVal = curVal;
                }
                return curVal;
              }
            }
            throw "invalid envelope state";
          }
        }
        globalThis.ADSR = ADSR;
        globalThis.adsr = registerClass("adsr", ADSR);

        globalThis.ad = register("ad", (gate = 0, attack = 0.02, decay = 0.1) =>
          adsr(gate, attack, decay, 0, decay)
        );

        const MAX_DELAY_TIME = 10;
        class Delay extends Node {
          writeIdx = 0;
          readIdx = 0;
          buffer = new Float32Array(MAX_DELAY_TIME * sampleRate); // .fill(0)
          write(s, delayTime) {
            this.writeIdx = (this.writeIdx + 1) % this.buffer.length;
            this.buffer[this.writeIdx] = s;
            // Calculate how far in the past to read
            let numSamples = Math.min(
              Math.floor(sampleRate * delayTime),
              this.buffer.length - 1
            );
            this.readIdx = this.writeIdx - numSamples;
            // If past the start of the buffer, wrap around
            if (this.readIdx < 0) this.readIdx += this.buffer.length;
          }
          update(input, delayTime) {
            this.write(input, delayTime);
            return this.buffer[this.readIdx];
          }
        }
        globalThis.Delay = Delay;
        globalThis.delay = registerClass("delay", Delay);

        class Fold extends Node {
          update(input = 0, rate = 0) {
            if (rate < 0) rate = 0;
            rate = rate + 1;
            input = input * rate;
            return (
              4 *
              (Math.abs(0.25 * input + 0.25 - Math.round(0.25 * input + 0.25)) -
                0.25)
            );
          }
        }
        globalThis.Fold = Fold;
        globalThis.fold = registerClass("fold", Fold);

        let perc = register("perc", (gate, decay) => gate.adsr(0, 0, 1, decay));

        class Lag extends Node {
          lagUnit = 4410;
          s = 0;
          update(input, rate) {
            // Remap so the useful range is around [0, 1]
            rate = rate * this.lagUnit;
            if (rate < 1) rate = 1;
            this.s += (1 / rate) * (input - this.s);
            return this.s;
          }
        }
        globalThis.Lag = Lag;
        globalThis.lag = registerClass("lag", Lag);

        class Slew extends Node {
          last = 0;
          update(input, up, dn) {
            const upStep = up * ISR;
            const downStep = dn * ISR;
            let delta = input - this.last;
            if (delta > upStep) {
              delta = upStep;
            } else if (delta < -downStep) {
              delta = -downStep;
            }
            this.last += delta;
            return this.last;
          }
        }
        globalThis.Slew = Slew;
        globalThis.slew = registerClass("slew", Slew);

        globalThis.applyDistortion = (x, amount) => {
          amount = Math.min(Math.max(amount, 0), 1);
          amount -= 0.01;
          var k = (2 * amount) / (1 - amount);
          var y = ((1 + k) * x) / (1 + k * Math.abs(x));
          return y;
        };
        globalThis.distort = registerRaw(
          "distort",
          (r, a) => `${r} = applyDistortion(${a.join(",")})`
        );
        globalThis.hpf = register("hpf", (input, cutoff, resonance = 0) =>
          input.sub(input.lpf(cutoff, resonance))
        );

        class Sequence extends Node {
          clockSgn = true;
          step = 0;
          first = true;
          update(clock, ...ins) {
            if (!this.clockSgn && clock > 0) {
              this.step = (this.step + 1) % ins.length;
              this.clockSgn = clock > 0;
              return 0; // set first sample to zero to retrigger gates on step change...
            }
            this.clockSgn = clock > 0;
            return ins[this.step];
          }
        }
        globalThis.Sequence = Sequence;
        globalThis.seq = registerClass("seq", Sequence);
        globalThis.midinote = registerRaw(
          "midinote",
          (r, [note]) => `${r} = (2 ** ((${note} - 69) / 12) * 440)`
        );

        globalThis.midi2freq = (midi) => Math.pow(2, (midi - 69) / 12) * 440;

        globalThis.range = registerRaw(
          "range",
          (r, [bip, a, b]) => `${r} = ((${bip} + 1) / 2) * (${b} - ${a}) + ${a}`
        );
        /* let log = registerNode("log", (r, a) => `${r} = Math.log(${a})`);
        let exp = registerNode("exp", (r, a) => `${r} = Math.exp(${a})`);
        let sin = registerNode("sin", (r, a) => `${r} = Math.sin(${a})`);
        let cos = registerNode("cos", (r, a) => `${r} = Math.cos(${a})`); */

        globalThis.unipolar = registerRaw(
          "unipolar",
          (r, [bip]) => `${r} = (${bip}+1)/2;`
        );
        globalThis.bipolar = registerRaw(
          "bipolar",
          (r, [uni]) => `${r} = ${uni}*2-1;`
        );

        globalThis._rangex = (sig, min, max) => {
          let logmin = Math.log(min);
          let range = Math.log(max) - logmin;
          const unipolar = (sig + 1) / 2;
          return Math.exp(unipolar * range + logmin);
        };
        globalThis.rangex = registerRaw(
          "rangex",
          (r, args) => `${r} = _rangex(${args.join(",")})`
        );

        globalThis.pan = register("pan", (input, pos) => {
          // (pos+1)/2 * PI/2 = (pos+1) * PI * 0.25
          return input;
          /* pos = add(pos, 1).mul(Math.PI, 0.25);
          return input.mul([Math.cos(pos), Math.sin(pos)]); */
        });

        globalThis.add = registerRaw("add", (r, a) => `${r} = ${a.join("+")}`);
        globalThis.sub = registerRaw("sub", (r, a) => `${r} = ${a.join("-")}`);
        globalThis.mul = registerRaw("mul", (r, a) => `${r} = ${a.join("*")}`);
        globalThis.div = registerRaw("div", (r, a) => `${r} = ${a.join("/")}`);
        globalThis.mod = registerRaw("mod", (r, a) => `${r} = ${a.join("%")}`);
        globalThis.n = registerRaw("n", (r, x) => `${r} = ${x}`);

        Node.prototype.apply = function (x) {
          return x(this);
        };
        // sine(240).raw(([n]) => `${n}/16`)
        /* let raw = register("raw", (...args) => {
          const compileSelf = args[args.length - 1];
          return new Node("raw", args.slice(0, -1), null, compileSelf);
        }); */
        /* let raw = (type, compileSelf) =>
          register((...args) => new Node(type, args, null, compileSelf));
        let raw = registerRaw('raw', ()) */
        // sine(100).raw((arg) => `${arg}/2`)
        Object.assign(globalThis, {
          Node,
        });
      </script>
    </template>
    <!-- graphviz -->
    <script>
      function gvjson2dot(json) {
        const { nodes, edges } = json;
        let renderProps = (props) =>
          `[${Object.entries(props)
            .map(([key, value]) => `${key}="${value}"`)
            .join(",")}]`;
        return `digraph {
            bgcolor="transparent";
            rankdir="LR";
            node [penwidth=4];
            edge [penwidth=2];
            ${nodes
              .map((node) => `  "${node.id}" ${renderProps(node)}`)
              .join("\n")}
            ${edges
              .map(
                (edge) =>
                  `  ${edge.source} -> ${edge.target} ${renderProps(edge)}`
              )
              .join("\n")}
            }`;
      }
      function nodes2gvjson(nodes, editNode, editEdge) {
        const gvnodes = [],
          gvedges = [];

        let style = {
          color: "white",
          fontcolor: "white",
          fontsize: "10",
          fontname: "monospace",
        };
        let getInput = (input) => {
          if (typeof input === "string") {
            return nodes[Number(input)];
          }
          return input;
        };
        nodes.forEach((node, i) => {
          const ins = node.ins.map(getInput);
          const label = `${node.type} ${ins
            .map((input) =>
              typeof input === "object"
                ? "_"
                : Math.round(input * 10000) / 10000
            )
            .join(" ")}`;
          let gvnode = {
            id: node.id,
            label,
            ordering: "in",
            width: "0.5",
            height: "0.4",
            ...style,
          };
          if (editNode) {
            gvnode = editNode(gvnode);
          }
          gvnodes.push(gvnode);
          for (let i in ins) {
            if (typeof ins[i] !== "object") {
              continue;
            }
            if (ins[i].id === undefined) {
              console.log("undefined source id", ins[i], "for node", node);
            }
            let gvedge = {
              label: "",
              id: gvedges.length,
              source: ins[i].id ?? "whuuuat",
              target: node.id,
              directed: "true",
              ...style,
            };
            if (editEdge) {
              gvedge = editEdge(gvedge);
            }
            gvedges.push(gvedge);
          }
          return node;
        });
        return { nodes: gvnodes, edges: gvedges };
      }
      function nodes2dot(nodes, editNode, editEdge) {
        const flat = nodes2gvjson(nodes, editNode, editEdge);
        const dot = gvjson2dot(flat);
        return dot;
      }
      async function renderDot(dot, container) {
        // this breaks my rule of self-contained html :/
        // but graphviz is just so good..
        // i don't want to segway into graph layouting rn...
        // download the file here: https://unpkg.com/@hpcc-js/wasm@2.18.0/dist/graphviz.js
        // sorry if you're living in 2051 and npm has collapsed already..
        const { Graphviz } = await import(
          "/libs/@hpcc-js/wasm-graphviz/graphviz.js"
        );
        const graphvizLoaded = Graphviz.load();
        const graphviz = await graphvizLoaded;
        const svg = await graphviz.layout(dot, "svg", "dot", {});
        const base64 = btoa(unescape(encodeURIComponent(svg)));
        const dataUrl = `data:image/svg+xml;base64,${base64}`;
        const img = document.createElement("img");
        img.src = dataUrl;
        img.style.maxHeight = "200px";
        img.style.width = "600px";
        container.innerText = "";
        container.appendChild(img);
      }
      function renderNodes(nodes, container, editNode, editEdge) {
        const dot = nodes2dot(nodes, editNode, editEdge);
        return renderDot(dot, container);
      }
    </script>
  </head>
  <body>
    <h2>ðŸŒ± spawning audio graphs II</h2>
    <p>
      after learning how to
      <a href="/kabelsalat/spawning-audio-graphs.html">spawn audio graphs</a>
      within my
      <a href="/audio-dsp/worklets3.html">dsp-repl</a>, i want to port more
      features from
      <a href="https://kabel.salat.dev/" target="_blank" style="color: yellow"
        >kabelsalat</a
      >. first, i want to add graphviz again, as it will become handy in
      understanding spawning better:
    </p>
    <dsp-repl rows="8"
      ><!-- 
$.m ??= 0
$.m = ($.m+5)%24
midinote($.m+54).sine()
.group(2,0.1,1)
.play()
--></dsp-repl
    >
    <p>
      after evaluating a bunch of times, we can see the individual voices as
      branches that are summed together at the end! pay attention to the
      fadein/fadeout change on evaluation.
    </p>
    <p>
      next up, <a href="/kabelsalat/feedback.html">feedback</a> and
      <a href="/kabelsalat/multichannel-expansion.html"
        >multichannel expansion</a
      >:
    </p>
    <dsp-repl rows="8"
      ><!-- 
zaw([55,110,220,330]).lpf( sine(.25).range(.3,.7) )
.mix(2)
.mul(impulse(4).perc(.1).lag(.05))
.add(x=>x.delay(zaw(.01).range(.005,.02)).mul(.9))
.add(x=>x.delay(.3).mul(.7))
.fold().mul(.6)
.spawn(1,1,1)
--></dsp-repl
    >
    <p>to make this run, i've added a bunch of ugens as well..</p>

    <p>
      let's test an even larger graph.. here's a great one by
      <a href="https://pulusound.fi/" target="_blank" style="color: yellow"
        >pulu</a
      >:
    </p>
    <dsp-repl rows="16"
      ><!-- 
// stardust
// by pulu : https://pulusound.fi
let mel = n(sine(0.1).rangex(1, 5)).dust().apply(g => 
  g.ad(0.001,sine(11.23).rangex(0.07, 0.2)).mul(
    g.seq(52,57,60,59,45,52,59,45,57).add(g.seq(12,12,24,12,12,12)).midinote()
      .mul(g.ad(0.001,0.03).bipolar().rangex(1,noise().hold(g).rangex(0.5,2)))
      .sine()
      .mul(noise().hold(g).lag(0.001).range(0.2,1))
      .pan(noise().hold(g).lag(0.003).mul(0.8))
  )
)
  .add(x => x.delay(sine(0.121).rangex(0.333, 0.347)).mul(sine(0.54).rangex(0.3, 0.7)))
  .add(x => x.delay(sine(0.131).rangex(0.543, 0.557)).mul(sine(0.64).rangex(0.3, 0.7)))
  .mul(1.05);
let wind = noise()
  .mul(dust(18).ad(0.003,0.05).bipolar().rangex(0.6,1))
  .add(noise().hold(dust(500)))
  .mul(n(0.7).apply(r => noise().hold(impulse(r)).slew(r).rangex(0.4,1)))
  .distort(0.5)
  .lpf(n(0.2).apply(r => noise().hold(impulse(r)).slew(r).rangex(0.5,0.9)),0.2)
  .hpf(n(0.33).apply(r => noise().hold(impulse(r)).slew(r).rangex(0.3,0.4)))
  .pan(sine(0.12).mul(0.7))
  .add(x => x.delay(0.65).mul(0.72))
  .mul(0.2);
let drone = add(...[0,7,10,12].map((x,i) =>
  n(x+45).midinote().sine()
    .mul(n(x/25).sine(0, i/2*Math.PI).unipolar())
    .pan(sine(1, 0, i/2*Math.PI).mul(0.6))
))
  .mul(0.8);
add(mel, wind, drone).spawn(1,1,1)
--></dsp-repl
    >
    <p>
      maybe not surprisingly, the audio starts to crack for subsequent
      evaluations.. this is likely happening because compilation blocks the
      audio thread for too long, which means we cannot fill the buffer in time..
      the block size in AudioWorklet's is 128 samples, which is ~2.9ms at
      44.1kHz and ~2.6ms at 48kHz. so any computation that takes longer than
      that will cause ugly cracks in the audio. to avoid this, we could:
    </p>
    <ol>
      <li>compile on the main thread, run the generated code in the worklet</li>
      <li>
        compile in a worker and also generate the audio there, use worklet as
        audio buffer sink
      </li>
    </ol>
    <p>
      i'd assume 1 to be the fastest, but less flexible. when using a worker as
      in 2, we can use a bigger block size, making sure our compilation fits in.
      so it seems we need to choose between latency and dynamicness..
    </p>
    <p>fwiw here's a stress test:</p>
    <dsp-repl rows="6"
      ><!-- 
sine(random()*200+200)
.spawn(200,1,1)
--></dsp-repl
    >
    <p>
      here, we can go pretty far (>200 sine waves on my machine), as the
      compilation cost is pretty low with this graph.
  </p>
    <details>
      <summary id="loc">show page source</summary>
      <pre id="pre"></pre>
    </details>
    <p>
      <a href="/">back to garten.salat</a>
    </p>
    <script>
      const html = document.querySelector("html").outerHTML;
      const loc = html.split("\n").length;
      document.querySelector("#pre").textContent = html;
      document.querySelector("#loc").textContent = `show source (${loc} loc)`;
    </script>
  </body>
</html>
