<!DOCTYPE html>
<html>
  <!-- license: AGPL-3.0 -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ðŸŒ± graph compilation</title>
    <style>
      body {
        background-color: #222;
        max-width: 500px;
        margin: auto;
        font-family: serif;
        font-size: 1.2em;
        color: #edd;
        padding: 20px 8px;
      }
      @font-face {
        font-family: "FontWithASyntaxHighlighter";
        src: url("/fonts/FontWithASyntaxHighlighter-Regular.woff2")
          format("woff2");
      }
      a {
        color: cyan;
        font-size: 1em;
      }
      textarea,
      pre {
        box-sizing: border-box;
        font-family: "FontWithASyntaxHighlighter", monospace;
        padding: 8px;
        font-size: 12px;
        border: 0;
        outline: none;
        overflow: auto;
        background-color: #44444490;
        color: white;
        width: 100%;
        margin-top: 8px;
        box-sizing: border-box;
      }
    </style>
  </head>
  <body>
    <h2>ðŸŒ± a graph compiler</h2>
    <p>
      After building <a href="./graph-language.html">a graph language</a>, we
      can now use these graphs to actually do something. A graph can represent
      the flow of data in a system. We can turn a graph into a piece of runnable
      code in any language.. For the purpose of demonstration, let's compile our
      math graph language back to JS:
    </p>
    <textarea id="input" type="text" rows="4" spellcheck="false"></textarea>
    <label
      >generated code:
      <pre id="generated"></pre>
    </label>
    <label
      >result:
      <pre id="result"></pre>
    </label>
    <p>
      You can edit the user code and run it with ctrl+enter to see what changes
      in the generated code and output.
    </p>
    <p>
      The key is to first sort nodes by dependency (topoSort), then we can
      generate the output code line by line. Each node can define its compiled
      output, which allows compiling to any language.
    </p>
    <details>
      <summary>show page source</summary>
      <pre id="pre"></pre>
    </details>
    <p>
      <a href="/">back to garten.salat</a>
    </p>
    <script>
      // generic graph lib
      class Node {
        constructor(type, ins, compileSelf) {
          this.type = type;
          this.ins = ins;
          this.compileSelf = compileSelf;
        }
      }
      // registers a function on the node class + standalone
      let register = (type, compile) => {
        Node.prototype[type] = function (...args) {
          return new Node(type, [this, ...args], compile);
        };
        return (...args) => new Node(type, args, compile);
      };
      // sort nodes by dependencies
      function topoSort(graph) {
        const sorted = [];
        const visited = new Set();
        function dfs(node) {
          if (!(node instanceof Node) || visited.has(node)) {
            return; // constant values or already visited nodes
          }
          visited.add(node);
          for (let i in node.ins) {
            dfs(node.ins[i]);
          }
          sorted.push(node);
        }
        dfs(graph);
        return sorted;
      }
      // convert node to code + metadata
      Node.prototype.compile = function () {
        let nodes = topoSort(this);
        const getRef = (input) =>
          typeof input !== "object" ? input : `v${nodes.indexOf(input)}`;
        let lines = [];
        for (let id in nodes) {
          const node = nodes[id];
          const args = node.ins.map(getRef);
          const ref = getRef(node);
          lines.push(node.compileSelf(node, ref, args));
        }
        const last = getRef(nodes[nodes.length - 1]);
        return { lines, last };
      };
      // the following code uses the above graph lib in a more specific way
      // arithmetic example
      const compileSelf = (node, ref, args) =>
        `let ${ref} = lib.${node.type}(${args.join(",")})`;
      const add = register("add", compileSelf);
      const sub = register("sub", compileSelf);
      const mul = register("mul", compileSelf);
      const div = register("div", compileSelf);
      const lib = {
        add: (a, b) => a + b,
        sub: (a, b) => a - b,
        mul: (a, b) => a * b,
        div: (a, b) => a / b,
      };
      const input = document.querySelector("#input");
      const generated = document.querySelector("#generated");
      const result = document.querySelector("#result");
      const graph = document.querySelector("#graph");
      input.value = `add(1, 2).mul(20).div(2).add(12)`;
      let update = () => {
        const node = new Function(`return ${input.value}`)();
        console.log("node", node);
        const unit = node.compile();
        unit.lines.push(`return ${unit.last}`);
        const code = unit.lines.join("\n");
        console.log("code", code);
        generated.innerText = code;
        const fn = new Function("lib", code);
        const res = fn(lib);
        console.log("res", res);
        result.innerText = res;
      };
      // update on ctrl+enter
      input.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
          update();
        }
      });
      update();

      document.querySelector("#pre").textContent =
        document.querySelector("html").outerHTML;
    </script>
  </body>
</html>
