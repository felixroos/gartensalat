<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ðŸŒ± lispy modular synth</title>
    <style>
      body {
        background-color: #222;
        max-width: 500px;
        margin: auto;
        font-family: serif;
        font-size: 1.2em;
        color: #edd;
        text-align: left;
        padding: 20px 8px;
      }
      @font-face {
        font-family: "FontWithASyntaxHighlighter";
        src: url("/fonts/FontWithASyntaxHighlighter-Regular.woff2")
          format("woff2");
      }
      a {
        color: cyan;
        font-size: 1em;
        cursor: pointer;
      }
      textarea,
      pre {
        font-family: "FontWithASyntaxHighlighter", monospace;
        padding: 8px;
        font-size: 12px;
        border: 0;
        overflow: auto;
        outline: none;
        background-color: #44444490;
        color: white;
        width: 100%;
        box-sizing: border-box;
      }
      ul,
      ol {
        padding-left: 20px;
      }
    </style>
    <script>
      // render codeblock from script tag
      let codeblock = (scriptElement, indent = 0) => {
        const script = document.currentScript;
        setTimeout(() => {
          const pre = document.createElement("pre");
          pre.textContent = getCode(scriptElement, indent);
          script.after(pre);
        }, 1);
      };
      function getCode(scriptElement, indent = 0) {
        return scriptElement.innerText
          .split("\n")
          .map((line) => line.slice(indent))
          .filter((x) => x && !x.startsWith("codeblock("))
          .join("\n");
      }
    </script>
  </head>
  <body>
    <h2>ðŸŒ± lispy modular synth</h2>
    <p>
      it's time to use my little
      <a href="/lisp/sugar.html">lispy language</a> to make sound! this time,
      i'm using
      <a href="https://kabel.salat.dev/learn/">kabelsalat</a>
      as a target.
    </p>
    <div><a id="play">play</a> | <a id="stop">stop</a></div>
    <textarea rows="24" id="code" spellcheck="false"></textarea>
    <div>
      <small>ðŸ’¡ hit ctrl+enter to update the code.</small>
    </div>
    <p>
      inspired by common lisp, i've added some more goodies to the language:
    </p>
    <ul>
      <li>fn: an anonymous function</li>
      <li>def: a global variable definition</li>
      <li>x: y shortcut for setting variables</li>
      <li>:x shortcut for gettin variables</li>
    </ul>
    <!-- <pre>
(poly 55 110 220 330 
> saw 
> lpf ( sine .25 > range .3 .7 )
> mix 2
> mul ( impulse 4 > perc .1 > lag .05 )
> add (fn (x) (x > delay (zaw .01 > range .005 .02) > mul .9))
> add (fn (x) (x > delay .3 > mul .7))
> fold > mul .6 > out)
    </pre> -->

    <!-- 
(impulse 4 > seq 100 200 300 > mul (impulse 1 > seq .5 1)
> saw (sine .2 > range .1 .5) 
> lpf (sine .5 > range .3 .6) (sine .4 > range 0 .1)
> mul (impulse 8 > ad .01 .1)
> mul (zaw 1 > range 1 0 > lag .1)
> out)
-->

    <!-- 
(lfo: fn (f a b) (sine f > range a b))

(pulse 220 .2 
> lpf (sine .5 > range .2 .8) 
> fold 
> out)
 -->

    <!-- 
(lfo: fn (f a b) (sine f > range a b))
(imp: impulse 4)

(imp > seq 0 3 7 12 > add 42 > midinote
> pulse .2 
> mul (imp > ad .01 .15)
> out) 
 -->

    <!-- 
(lfo: fn (f a b) (sine f > range a b))
(imp: impulse 1)

(seq imp 0 3 7 12 > add 42 > midinote
> pulse .5
> mul (imp > ad .01 .15)
> add (fn (x) (x > delay .3 > mul .8))
> out)
-->

    <!-- 
(
fm2: fn (freq fmh fmi) 
(modfreq: freq > mul fmh)
(modgain: modfreq > mul fmi)
(sine modfreq > mul modgain > sine)
)

(
impulse 6 
> apply (fn (imp) (
 imp > seq 50 50 100 50 300
 > fm2 1.005 (sine .5 > range 4 20)
 > mul (imp > ad 1 1)
))
> add (fn (x) (x > delay .3 > mul .7))
> mul .5 > clip > out
)
 -->

    <script type="module">
      // https://garten.salat.dev/lisp/parser.html
      class LispParser {
        // these are the tokens we expect
        token_types = {
          open_list: /^\(/,
          close_list: /^\)/,
          pipe: /^\>/,
          set_var: /^[a-zA-Z_][a-zA-Z0-9_]*\:/, // imp: impulse 2
          // todo: change ":" to "=" and allow arbitrary spaces
          //assignment: /^\=/, // <- use this and do pattern matching later
          number: /^[0-9\.\/]+/, // not super accurate..
          word: /^[a-zA-Z0-9\.\#\=\+\-\*\/]+/,
        };
        // matches next token
        next_token(code) {
          for (let type in this.token_types) {
            const match = code.match(this.token_types[type]);
            if (match) {
              return { type, value: match[0] };
            }
          }
          throw new Error(`could not match "${code}"`);
        }
        // takes code string, returns list of matched tokens (if valid)
        tokenize(code) {
          let tokens = [];
          while (code.length > 0) {
            code = code.trim();
            const token = this.next_token(code);
            code = code.slice(token.value.length);
            tokens.push(token);
          }
          return tokens;
        }
        // take code, return abstract syntax tree
        parse(code) {
          this.tokens = this.tokenize(code);
          const expressions = [];
          while (this.tokens.length) {
            expressions.push(this.parse_expr());
          }
          return expressions;
        }
        // parses any valid expression see
        parse_expr() {
          if (!this.tokens[0]) {
            throw new Error(`unexpected end of file`);
          }
          let next = this.tokens[0].type;
          if (next === "open_list") {
            return this.parse_list();
          }
          return this.consume(next);
        }
        // makes sure given elements are a non nested list
        reify_list(elements) {
          // if it's a single list element, take it as is
          if (elements.length === 1 && elements[0].type === "list") {
            return elements[0];
          }
          if (elements.length === 1 && elements[0].type === "number") {
            return this.wrap_n(elements[0].value);
          }
          // it's not a single list element -> wrap as list
          return { type: "list", children: elements };
        }
        resolve_pipes(children) {
          // saw 55 > lpf .5 = lpf (saw 55) .5
          while (true) {
            let pipeIndex = children.findIndex(
              (child) => child.type === "pipe"
            );
            if (pipeIndex === -1) break;
            let leftSide = children.slice(0, pipeIndex);
            if (leftSide.length === 1) {
              leftSide = leftSide[0];
            } else {
              leftSide = this.reify_list(leftSide);
            }
            const callee = children[pipeIndex + 1];
            const rightSide = children.slice(pipeIndex + 2);
            children = [callee, leftSide, ...rightSide];
          }
          return children;
        }
        wrap_n(value) {
          return {
            type: "list",
            children: [
              { type: "word", value: "n" }, // this is very kabelsalat specific...
              { type: "word", value },
            ],
          };
        }
        resolve_set_var(children) {
          const varIndex = children.findIndex(
            (child) => child.type === "set_var"
          );
          if (varIndex === -1) return children;
          if (varIndex !== 0) {
            throw new Error('assignments need to be of format "x = ..."');
          }
          const name = children[0].value.slice(0, -1); // cut off :

          let rightSide = children.slice(1);
          rightSide = this.make_list(rightSide);

          return [
            { type: "word", value: "def" },
            { type: "word", value: name },
            rightSide,
          ];
        }

        make_list(children) {
          // children = this.reify_list(children).children; // (imp: (impulse 2)) = (imp: impulse 2)
          children = this.resolve_set_var(children);
          children = this.resolve_pipes(children);
          return { type: "list", children };
        }
        parse_list() {
          this.consume("open_list");
          let children = [];
          while (this.tokens[0]?.type !== "close_list") {
            children.push(this.parse_expr());
          }
          this.consume("close_list");
          return this.make_list(children);
        }
        consume(type) {
          // shift removes first element and returns it
          const token = this.tokens.shift();
          if (token.type !== type) {
            throw new Error(`expected token type ${type}, got ${token.type}`);
          }
          return token;
        }
      }

      // https://garten.salat.dev/lisp/interpreter.html
      class Zilp {
        constructor(evaluator, preprocessor) {
          this.parser = new LispParser();
          this.evaluator = evaluator;
          this.preprocessor = preprocessor;
        }
        // a helper to check conditions and throw if they are not met
        assert(condition, error) {
          if (!condition) {
            throw new Error(error);
          }
        }
        run(code) {
          const expressions = this.parser.parse(code);
          return expressions.map((exp) => this.evaluate(exp));
        }
        process_args(args) {
          return args.map((arg) => {
            if (arg.type === "list") {
              return this.evaluate(arg);
            }
            return arg.value;
          });
        }
        evaluate(ast) {
          // console.log("call", ast);
          // for a node to be callable, it needs to be a list
          if (ast.type === "word") {
            // non-lists evaluate to their value
            return ast.value;
          }
          this.assert(
            ast.type === "list",
            `function call: expected list, got ${ast.type}`
          );
          // the first element is expected to be the function name
          this.assert(
            ast.children[0]?.type === "word",
            `function call: expected first child to be word, got ${ast.type}`
          );
          // look up function in lib
          const name = ast.children[0].value;

          // lambda function
          if (name === "fn") {
            const fnArgs = ast.children[1].children.map((arg) => arg.value);
            let lines = [];
            const statements = ast.children.slice(2);
            let fnBody;
            // multiple statements
            for (let i in statements) {
              let evaluated = this.evaluate(statements[i]);
              if (i == statements.length - 1) {
                evaluated = `return ${evaluated}`;
              }
              lines.push(evaluated);
            }
            fnBody = `{${lines.join(";")}}`;
            console.log("fnBody", fnBody);
            //const fnBody = this.evaluate(ast.children[2]);
            return `(${fnArgs.join(",")}) => ${fnBody}`;
          }
          if (name === "def") {
            const pName = ast.children[1].value;
            const pBody = this.evaluate(ast.children[2]);
            //return `let ${pName} = ${pBody};`;
            return `let ${pName} = ${pBody}`;
          }

          // process args
          const args = this.process_args(ast.children.slice(1));

          return `${name}(${args.join(",")})`;
        }
      }

      // wire everything together
      import { SalatRepl } from "./@kabelsalat/web/index.mjs";

      window.apply = (node, fn) => node.apply(fn);
      const zilp = new Zilp();
      const input = document.querySelector("#code");
      /* input.value = `(lfo: fn (f a b) (sine f > range a b))
(imp: impulse 2)

(seq imp 0 3 7 12
> add (:imp > clockdiv 8 > seq 0 5) 
> add 42
> midinote
> saw (lfo .3 .1 .5)
> lpf (lfo .2 .3 .8) .2
> mul (ad imp .01 .1)
> add (fn (x) (:x > delay .3 > mul .9))
> out)
`; */
      input.value = `(
fm2: fn (freq fmh fmi) 
(modfreq: freq > mul fmh)
(modgain: modfreq > mul fmi)
(sine modfreq > mul modgain > sine)
)

(
impulse 6 
> apply (fn (imp) (
 imp > seq 50 50 100 50 300
 > fm2 1.005 (sine .5 > range 4 20)
 > mul (imp > ad 1 1)
))
> add (fn (x) (x > delay .3 > mul .7))
> mul .5 > clip > out
)`;

      const repl = new SalatRepl();

      function update(lispCode = input.value) {
        const t = performance.now();
        const jsCode = zilp.run(lispCode).join("\n");
        console.log(jsCode);
        repl.run(jsCode);
      }

      document.querySelector("#play").onclick = () => update();
      document.querySelector("#stop").onclick = () => repl?.stop();

      input.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
          update(input.value);
        }
        if ((e.ctrlKey || e.altKey) && e.key === ".") {
          e.preventDefault();
          repl?.stop();
        }
      });
    </script>

    <details>
      <summary id="loc">show page source</summary>
      <pre id="pre"></pre>
    </details>
    <br />
    <a href="/">back to garten.salat</a>
    <script>
      // render source code
      const html = document.querySelector("html").outerHTML;
      const loc = html.split("\n").length;
      document.querySelector("#pre").textContent = html;
      document.querySelector("#loc").textContent = `show source (${loc} loc)`;
    </script>
  </body>
</html>
